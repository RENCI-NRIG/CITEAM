[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About CITEAM",
    "section": "",
    "text": "The Cyberinfrastructure Training for Electron Microscopy–Enabled Materials Science (CITEAM) project brings together PIs with expertise in CI as well as in imaging-enabled materials science to develop an innovative training program targeting the materials science community that relies on advanced microscopes (e.g., Transmission Electron Microscopes (TEM)) for research.\nThe training program covers several relevant thematic areas – TEM instrument software, image analysis, scientific computing, application of AI in TEM image and data analysis, diffraction and spectroscopy data analysis, distributed computing for EM data processing, data curation and FAIR principles.\nCITEAM includes an additional element of “training the trainers” by exposing the relevant CI contributors – the research facilitators and laboratory staff scientists – to advanced CI topics, empowering them to guide others and innovate in the use of CI for materials science.\nTraining is offered in multiple modalities: self-paced modules, video lectures, templates and catalogs, office hours, sessions at the annual CITEAM Users’ Workshop, and tutorials at domain science conferences.\nCITEAM also devotes a significant effort to community building through a three-pronged coordination network comprising imaging laboratories, domain science communities, and experts from national CI resource providers. This approach ensures scalability, sustainability, and broad dissemination of training materials and practices.\nThere are presently two sets of training modules available. The first one is a basic introduction to the Python programming language. Python has quickly become the dominant language for science and engineering, and all our remaining modules will use it. The second module is an introduction to electron microscope image processing and is, of course, written in Python."
  },
  {
    "objectID": "about.html#introductory-modules",
    "href": "about.html#introductory-modules",
    "title": "About CITEAM",
    "section": "Introductory Modules",
    "text": "Introductory Modules\n\nPRE 100: Python Programming and Jupyter notebooks\nPRE 101: Microscopy Image Processing Basics"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.out.html",
    "href": "preliminaries/PRE100/PE100-04Repetition.out.html",
    "title": "PE100-04: Repetition",
    "section": "",
    "text": "We started off learning Python with just simple lists of statements…\ntemperature = 100\nprint(\"It's\", temperature, \"celsius\")\nfaren_t = temperature * (9/5) + 32\nprint(\"or\", faren_t, \"in pagan units.\")\n\nIt's 100 celsius\nor 212.0 in pagan units.\nThen we added the if statement so we could control whether or not certain statements would execute or not:\nif temperature &gt;= 100:\n    print(\"Good chance it's boiling.\")\nelif temperature &gt; 3000:\n    print(\"Odds are it's plasma by now.\")\nelse:\n    print(\"You could probably run the experiment and it might even work.\")\n\nGood chance it's boiling.\nIn both of these cases, the code blocks only run once.\nThe problem is, sometimes we need things to run repeatedly. We want to look up all of the readings from an experiment or we need to compute the properties of something over dozens of temperatures each at dozens of pressures.\nPython gives us two different ways to make our programs repeat things in a loop.\nLet’s start with the while loop."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.out.html#while-loops",
    "href": "preliminaries/PRE100/PE100-04Repetition.out.html#while-loops",
    "title": "PE100-04: Repetition",
    "section": "While Loops",
    "text": "While Loops\nThe syntax of a while loop looks a bit like an if statement. Take a look:\n\ninstrument = 1\nwhile instrument &lt;= 2:\n   print(\"Looking at instrument number\", instrument)\n   print(\"and then maybe we'll look at the next one.\")\n   instrument = instrument + 1\nprint(\"Done with all that looping.\")\nprint(\"...and ready to do something else now.\")\n\nLooking at instrument number 1\nand then maybe we'll look at the next one.\nLooking at instrument number 2\nand then maybe we'll look at the next one.\nDone with all that looping.\n...and ready to do something else now.\n\n\nHere’s what the above code does. First, it creates a variable named “instrument” and sets it to 1. Then it goes into the while loop. The first time through, it checks to see if instrument is less than or equal to 2. It is (because we set it to 1 just a moment ago) so the while loop will execute the code block. This block prints out two lines and then it adds 1 to instrument. That means instrument now equals 2.\nThe second time through the loop, instrument equals 2. That satisfies the conditional statement of the while loop (2 is less than or equal to 2) so the code block runs again. Two more lines are printed out and then instrument is incremented one more time.\nThe while loop runs for a third time now. This time, 3 is not less than or equal to 2, so the conditional statement is false. This means the while loop is done - it won’t run its code block again, and the flow of control will go on to the next line after the while loop. It will run the two print statements explaining that the looping is over and it can go on to other tasks.\nLet’s look at another example. Let’s print out all the powers of two that are less than 928.\n\npower=0\ntwo_to_the_power = 2**power\n\nwhile two_to_the_power &lt; 928:  # Totally not Porsche related.\n    print(\"2 to the\", power,\"equals\",two_to_the_power)\n    power = power+1\n    two_to_the_power = 2**power\nprint(\"2 to the\", power,\"is too big.\")\n\n2 to the 0 equals 1\n2 to the 1 equals 2\n2 to the 2 equals 4\n2 to the 3 equals 8\n2 to the 4 equals 16\n2 to the 5 equals 32\n2 to the 6 equals 64\n2 to the 7 equals 128\n2 to the 8 equals 256\n2 to the 9 equals 512\n2 to the 10 is too big.\n\n\nDid you notice I sneaked something in there we haven’t talked about yet? See the “#” character on the line with the while statement? That indicates the rest of the line is a comment. Python will totally ignore it. It’s handy for leaving little notes to yourself, like “why did I choose 928 there when I could have put 944?” This is very, very important when writing full-fledged, standalone programs. If you don’t leave some notes for yourself, you’ll never remember what you were thinking when you go back to that code six months from now. Also, the next person who comes along and has to change something in your code will greatly appreciate the hints.\nLeaving comments in the code isn’t as big a deal in Jupyter notebooks… you can write rather substantial notes in a Markdown cell complete with boldface, italics, and whatever other fanciness you desire. On the other hand, it’s also nice to be able to leave your comments in the just the right place in the code so it flows effortlessly through your comprehension as you read it. Let experience and personal opinion be your guide here."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.out.html#reading-information-from-the-outside-world",
    "href": "preliminaries/PRE100/PE100-04Repetition.out.html#reading-information-from-the-outside-world",
    "title": "PE100-04: Repetition",
    "section": "Reading information from the outside world",
    "text": "Reading information from the outside world\nNotice that in both of those cases, we actually did know how many times the loop would run. We know that 2 to the 9th is 512 and so we know the while loop will only run that far. In fact, in every example we’ve had so far we’ve know what the output will be because we always have the same inputs. Computer software wouldn’t be terribly interesting if it could only run specific, known, canned inputs. Fortunately, Python gives us several ways to bring data into our programs.\nThe simplest way to bring data into a Python program is to edit the program and change the values we assign to variables. This is sort of the reducto ad absurdum method, but honestly it isn’t a bad way to handle very small amounts of input. It’s even easier in Jupyter notebooks since the code is just sitting there looking at us, waiting to be edited. For values that aren’t going to change very often (your name, perhaps, or the chargeback account number for using some instrument, for instance) then just assigning a value to a variable and editing it every once and a while is a fine way to go.\nAnother way to get data into a Python program is to read it in from where the user is running the program. For doing this, Python provides a function called “input” which takes an optional argument, specifically a string that is printed as a prompt. Python then waits for the user to type something as a response. When they do, that string is returned to the calling program. Here’s a simple example:\n\nyour_name = input(\"Please enter your name\")\nprint(\"Hello,\", your_name)\n\nHello, Erik\n\n\nWhen the above code runs, the prompt “Please enter your name” is displayed right below the code cell and a text entry box is placed beside it. When you enter your name, it greets you.\nIf we were running this tiny little snippet of code as a regular program, the interaction would be in the terminal emulator window that we ran the program in. Because this is running in Jupyter, though, the interaction is directly in the notebook. The prompt and the entry blank occur just below the running code cell.\nWhat will happen when we run the following?\n\nresponse = input(\"Enter a number between 4 and 8\")\nnew_value = response + 6.5\nprint(new_value)\n\nWow! Python couldn’t run that and it “threw an error”. We’ll examine Python’s error handling facilities later, but for now we’ll just assume that means it came to a screeching halt. Looking at the error message, it seems there is some problem with trying to add a real number (a floting point number) to a string."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.out.html#type-casting",
    "href": "preliminaries/PRE100/PE100-04Repetition.out.html#type-casting",
    "title": "PE100-04: Repetition",
    "section": "Type Casting",
    "text": "Type Casting\ninput() prompts the user and returns the string they entered, but what if we want the user to enter a number? What do we do then? The answer is we’ll use a process known as type casting. The act of type casting is no more than converting information from one type to another.\nThere are three very useful functions for type casting: int(), float(), and str(). Let’s see them in action…\n\n# three conversions:\n\n# first, string to float:\nthe_sum = 6.554 + float(\"9.9\")\nprint(the_sum)\n\n# next, string to integer:\nthe_integer_number = int(\"34543456\")\nprint(the_integer_number)\n\n#finally, integer to string:\nhandy_string = str(2+2)\nprint(handy_string)\n\n16.454\n34543456\n4\n\n\nWhat did the above do? First, it converted the string “9.9” (literally, three characters… it’s a string) to a “float” (a floating point number, some languages will call that a real number). The second example takes a string of 8 characters and interprets them as an integer. That value is what gets returned and stored in our variable. Finally, we copmute the number 4 by adding 2+2, and then we let the str() function convert that to a single character long string having just the character “4”.\nBy now we know enough to be able to ask the user for a number and get something back that we can actually do math with.\n\nuser_response = input(\"Enter a number between 17 and 34\")\nselected_number = float(user_response)\nselected_number\n\nThere’s an even easier way, though. Just like function composition worked when you took precalculus, the results of a Python function can be used as the argument to another. Hence:\n\nselected_number = float(input(\"Enter a number between 17 and 34\"))\nselected_number\n\n26.0\n\n\nSometimes, function calls can be nested really deeply. Personally, when it comes time to debug code like that I find myself printing it out and coloring each level with a different highlighter pen."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.out.html#putting-it-together-while-loops-to-get-user-input",
    "href": "preliminaries/PRE100/PE100-04Repetition.out.html#putting-it-together-while-loops-to-get-user-input",
    "title": "PE100-04: Repetition",
    "section": "Putting it together: while loops to get user input",
    "text": "Putting it together: while loops to get user input\nThe great thing about a while statement is that it can loop zero times, one, two, or twelve trillion. Best of all, we don’t have to know how many ahead of time. We could do the following:\nprint(“Computing an average.”)\nsum=0.0 counter=0 data_point = float(input(“Enter a number, or enter negative num to stop”)) while data_point &gt;= 0.0: sum = sum+data_point counter = counter+1 data_point = float(input(“Enter a number, or enter negative num to stop”))\nprint(“Average value is”, sum/counter)\nWhen we run the code above, we’re prompted to keep entering numbers until we finally enter -999. Each time it goes through the loop it keeps track of the running total of the numbers and the count of how many numbers have been entered. Once it’s done, it divides the total by the count and displays that as the average.\nLet’s step through what happens when the user enters 1, 2, 3, and -999: 1. The sum and counter variables are initialized to zero. 1. The user is prompted to enter a number, possibly a negative number to indicate no more data, and that input is type cast to a floating point number. 1. The while loop’s condition will be met any time a positive number was input (greater than or equal to zero). 1 is a positive number, so run the loop body. 1. This first time through, we’ll add the 1 that was input to our running total, which is now 1. 1. And increment the count, now equal to 1. 1. AND PROMPT THE USER FOR ANOTHER NUMBER!!! 1. Back at the while statement again, we check the condition and, yes, 2 is a positive number, so we run the loop’s code block. 1. Update the sum and count, and then… 1. PROMPT THE USER FOR ANOTHER VALUE!!! 1. Running the while statement again, the user entered 3, and 3 is positive, so the clode block will be executed. 1. Update the sum (now 6) and count (now 3). 1. Prompt for another number 1. Back at the while statement, we check and see that -999 is not a positive number, so we skip the code block and resume by running whatever follows it. 1. Having exited the while loop entirely, print out the average value by dividing sum/count.\nAll the boldface and all-capitals lines above are there to emphasize how important it is to make sure your while loop isn’t just checking the same thing over and over. If we didn’t get a new number from the user each time through, the value of data_point would never change. That would result in an infinite loop, causing Python to never be able to complete the code in that cell. If it ever happens to you, and it probably will, the “Interrupt Kernel” command on JupyterLab’s Kernel menu will stop the looping and let you get back to work.\nThe while loop is certainly versatile… it can be used any time you need to do something repeatedly. If you know how many times you need to have the code block execute, either when you write the code or when it’s running, then keep a variable that is incremented in the block every time and exit the while loop when the counter hits the right number.\nWhere while loops really shine is when it’s impossible to know ahead of time how many times the code block should run. The example above, where we keep accepting numbers until the user signals there aren’t any more, there’s no way to know how many times to execute that loop until we see a negative number. In a case like that, the while loop is the only practical solution.\nSo if while loops are so great and solve every problem, why do we need anything else? The big reason is expressiveness: they can be a little awkward to understand, especially when you’re looking at someone else’s code. Having the conditional test separated from the action that establishes when to stop makes it a little awkward to understand (or debug!) someone else’s code. This is especially true when we need to step through something by unusual increments.\nSo what are we to do in these cases?"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.out.html#for-loops",
    "href": "preliminaries/PRE100/PE100-04Repetition.out.html#for-loops",
    "title": "PE100-04: Repetition",
    "section": "For Loops",
    "text": "For Loops\nThe for loop is quite similar to the while loop. The difference is that for loops are controlled by a count whereas while loops are controlled by a condition.\nLet’s start with an example.\n\nfor the_value in range(1,4):\n    print(the_value)\n\n1\n2\n3\n\n\nThat is the simplest for loop you’ll see. Let’s look at the pieces. 1. The for statement itself 2. The name of the target variable whose value will be changing as the loop runs (“the_value” in this case”) 3. “in” - and if this reminds you of set membership then you’re on to something 4. “range()” - this is an example of an iterable, which means “something that can be stepped through”. 5. The colon… the one I forget 50% of the time. 6. The code block, in this case just a print statement.\nMost of the time, fairly close to “always”, the code block will take advantage of the target variable changing each time through. In our example, “the_value” is our target variable, as it loops through it will take on the values 1 through 3, and the code block has a print statement that uses it.\nBefore we examine the range() function, let’s take a look at another iterable. We’ll talk about lists in a later lesson, but for now we can just wave our hands around and understand enough for the moment.\n\nfor sample_weight in [123.6, 121.9, 119.4, 124.23219]:\n    print(\"The sample weighed\", sample_weight, \"grams.\")\n    if sample_weight &lt; 120:\n        print(\"Be careful! This sample might not be all you hoped for.\")\n        \n\nThe sample weighed 143.6 grams.\nThe sample weighed 141.9 grams.\nThe sample weighed 139.4 grams.\nThe sample weighed 144.23219 grams.\n\n\nYou can use the target variable as many times as you want to in the code block.\nNow let’s take a more detailed look at the range() function. In its most basic form it takes one argument - the stop value.\n\nfor i in range(4):\n    print(i)\n\n0\n1\n2\n3\n\n\nThis single-argument form starts at zero, counts up by one each time, and doesn’t include the stop value. This is different from every other programming language you’ll ever encounter. It’s just one of those things.\nWe’ve already seen the two-argument form. It takes a starting value and a stopping value, and iterates by one from the start until the last value that is less than the stop.\n\nfor i in range(7,10):\n    print(i)\n\n7\n8\n9\n\n\nAnd there’s even a three-argument form. The third argument is the amount to step by.\n\nfor i in range (12,20,3):\n    print(i)\n\n12\n15\n18\n\n\nThe step size doesn’t have to be a positive number…\n\nfor i in range(6, -3, -2):\n    print(i)\n\n6\n4\n2\n0\n-2\n\n\nIn case you’re curious, the step size cannot be zero. If you really want an infinite loop, and there are cases where it makes sense, you have to use a while loop instead.\nAs a general rule, any place where you can use an explicit value (a literal) you can use a variable. Arguments to a for loop are no exception:\n\nstart_value = int(input(\"where should we start? \"))\nend_value   = int(input(\"where should we run right up to and stop just short of it? \"))\nstep_size   = int(input(\"what should we step by? \"))\n\nfor i in range(start_value, end_value, step_size):\n    print(i)\n    \n\n13\n\n\nIf we need to do something a specific number of times, we need to pay attention to our starting and stopping conditions. I’ve messed this up so many times I know now to be careful. You’ve been warned.\n\nhow_many = int(input(\"How many numbers would you like to total up? \"))\nsum = 0\nfor i in range(1, how_many):\n    sum = sum + int(input(\"Enter a number \"))\nprint(\"They add up to\", sum)\n\nThey add up to 9\n\n\nNotice something wrong? If you ask it to total 3 numbers, it only prompts for two of them. There are a couple of ways to solve this. The easiest is to just use the one-argument form of range().\n\nhow_many = int(input(\"How many numbers would you like to total up? \"))\nsum = 0\nfor i in range(how_many):\n    sum = sum + int(input(\"Enter a number \"))\nprint(\"They add up to\", sum)\n\nThey add up to 15\n\n\nThat offers a little insight into why Python has it’s funny “up to but not including” semantics: zero is a perfectly legitimate number and a very natural starting point.\nThe only problem with the single-argument method is that the values that the target variable goes through include zero. This may or may not be a problem if that value is used inside the code block. If you really need to count from one instead of zero, you can increment the stopping value:\n\nhow_many = int(input(\"How many numbers would you like to total up? \"))\nsum = 0\nfor i in range(1, how_many + 1):\n    sum = sum + int(input(\"Enter a number \"))\nprint(\"They add up to\", sum)\n\nThey add up to 15\n\n\nAnd that behaved just like we expected.\nYou may have noticed a pattern already. We frequently need to compute a new value for an existing variable. What we’ve done so far has been along the lines of grand_total = grand_total + new_reading. Python gives us a shorthand way to write that. We could instead express that as grand_total += new_reading. There is no space between the plus and equals signs. The only reason this exists is to save you some typing. As you might expect, there are a few more of these Augmented Assignment Operators…\n\n\n\nOperator\nExample\nEquivalent\n\n\n\n\n+=\ncount += 1\ncount = count + 1\n\n\n-=\nx -= offset\nx = x - offset\n\n\n*=\nproduct *= val\nproduct = product * val\n\n\n/=\ny /= 3\ny = y / 3\n\n\n%=\nval %= 2\nval = val % 2\n\n\n\nOut of all of them, += is far and away the most commonly used one."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.out.html#nested-loops",
    "href": "preliminaries/PRE100/PE100-04Repetition.out.html#nested-loops",
    "title": "PE100-04: Repetition",
    "section": "Nested Loops",
    "text": "Nested Loops\nYou know what’s fun to put in a loop’s code block? Another loop! Best of all, it comes in pretty handy when dealing with high-dimensional data. Plenty of algorithms rely on nested loops, too. Take a look at this:\n\nfor x in range(5):\n    for y in range(4):\n        print(\"x=\",x,\" y=\", y)\n\nx= 0  y= 0\nx= 0  y= 1\nx= 0  y= 2\nx= 0  y= 3\nx= 1  y= 0\nx= 1  y= 1\nx= 1  y= 2\nx= 1  y= 3\nx= 2  y= 0\nx= 2  y= 1\nx= 2  y= 2\nx= 2  y= 3\nx= 3  y= 0\nx= 3  y= 1\nx= 3  y= 2\nx= 3  y= 3\nx= 4  y= 0\nx= 4  y= 1\nx= 4  y= 2\nx= 4  y= 3\n\n\nWhat’s going on here? Initially, the outer loop, the one that iterates zero through four and assigns it’s value to x, runs. When it starts running its code block for the x=0 pass, the for loop for the y variable starts. ‘y’ assumes the values 0 through 3, so the first four lines printed out are for x=0, y=0, then x=0, y=1, and so on through x=0, y=3. Once that inner for loop completes, the outer for loop gets to iterate again. Now the inside for loop runs again, only this time we have x=1. That’s why the next four lines are “x=1, y=0” through “x=1, y=3”. Every time the outer loop runs another iteration, the inner loop gets to run all the way from start to finish.\nIn later lessons, we’ll have a few opportunities to play with nested loops. In fact, we’ll get to do that in the very next lesson: Functions!"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-01Introduction.html",
    "href": "preliminaries/PRE100/PE100-01Introduction.html",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "",
    "text": "Welcome to the Programming Essentials - Python Programming and Jupyter Notebooks component of the X-CITE training materials. The intent behind this unit is to show new CHESS users how to write programs in Python for experimental data analysis.\nPrerequisites? None.\nThe training materials before you are designed both for scientists who may not have any programming experience whatsoever and for those who have at least some basic programming capability but in a language other than Python.\nPython’s adoption has exploded in the last decade. Much of its success can be attributed to productivity. Many programming languages force the programmer to deal with very small details to do even the simplest things. Python’s attitude is to just take care of all the minutae so we don’t have to. On top of that, Python’s popularity has resulted in hundreds of thousands of packages of useful code for specific tasks. If there is something you need to write a program for, it’s almost definite that someone else has had the same problem. There’s a good chance at least one of those people neatly wrapped up some of their code and made it available in one of the repositories on the internet. There’s no reason for you to reinvent the proverbial wheel again - take advantage of their work (don’t forget to cite it!) and get back to doing actual science that much sooner.\nYou’re currently looking at PE100-01 Introduction. If you are new to Python and especially if you’re new to programming, you should work through each of the modules in order. More experienced programmers might benefit from skipping directly to topics that interest them. Select one of the following:\n\nPE100-02 Types, Variables, and Operators - the heart of any programming language.\nPE100-03 Decision Structures - conditional statements (“if” statements”) change the program flow.\nPE100-04 Repetition - “while” and “for” loops let us do things over and over.\nPE100-05 Functions - Python comes with a lot of functions, but we can write even more.\nPE100-06 Files - Reading input from and storing your results to disk.\nPE100-07 Exceptions - Dealing with unexpected contingencies.\nPE100-08 Lists - Another kind of variable, and the key to structuring data storage.\nPE100-09 Strings - More details on working with text.\nPE100-10 Dictionaries - Like a simple database, look up information quickly."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-10Dictionaries.html",
    "href": "preliminaries/PRE100/PE100-10Dictionaries.html",
    "title": "PE100-10: Dictionaries",
    "section": "",
    "text": "Dictionaries are, conceptually, a special type of list. A list has an order to it. Elements are placed into a list in a particular order. Removing and inserting items changes the order in a well understood way. Because of this, yoiu can always access a list by looking into it at a specific integer index. None of this is possible with a dictionary. Instead, dictionaries have a better trick: all access is by searching.\nPython’s dictionaries store each of their elements as a pair of things, a key and a value. The key is the thing that can be searched for, and the value is the information that will be retured when that element is read.\nAn example will help:\n\nfavorite_food = { \"Alice\" : \"Apple Pie\", \\\n                 \"Bob\" : \"Ice Cream\",\\\n                 \"Charlie\" : \"Pizza\" }\nprint(favorite_food[\"Bob\"])\n                 \n\nIce Cream\n\n\nLet’s take that apart and see how it works.\n\nWe have the creation of the dictionary itself. We create a dictionary literal much like we do a list, only here we use curly brackets instead of square brackets.\nWe have key:value pairs. The keys we’re using are all strings (people’s names, in fact) but they could just as well be numbers. The values are also strings, but they can be anything we want. These keys and values are separated by colons (:).\nBetween each of the key:value pairs there is a comma.\nWe see how to look up information in a dictionary. It looks like indexing into a list to extract a particular element, except in this case we don’t give a positional index number but rather we give it a key to look up.\n\nWhen you think about it, looking for Bob’s favorite food by using favorite_food[\"Bob\"] is a pretty powerful tool. Rather than having to specify where to get something from, we can just specify what to get. This is why you’ll occasionally see dictionaries refered to as “Content Addressable Memory”. It’s nice to just get the data we want without having to step through every element of a list looking for it. It’s also faster: Python’s dictionaries use clever indexing so they can straight to what you’re looking for.\nDictionaries get their name, by the way, from real-world physical dictionaries. Suppose you have Webster’s 9th New Collegiate Dictionary in front of you. There are a lot of keys in there - each one of those words in alphabetical order is a key. There’s not really any way to look up something by page number alone - there’s no algorithm to tell me what page the definition for brisance is on. There’s no way to look up a word by knowing which word number it is. If brisance is the 8000th word in the dictionary, that knowledge does me no good. On the other hand, there is an algorithm for finding that definition by looking up the key word. I go to the “B”s, look for the “Br” part, and so forth until I find brisance. I can only look up things by key, not by position.\nOne of the great things about Python is its flexibility with data types. Lists can contain any data type. You can have lists of tuples of lists of strings if you want to. Dictionaries are similarly versatile. You can have dictionaries that contain, say, lists:\n\nfamily_info = { 'ages' : [6,8,36,38],\\\n               'names' : ['Jane', 'John', 'Alice', 'Bob'] }\n\nprint(family_info[\"names\"])\n\n['Jane', 'John', 'Alice', 'Bob']\n\n\nYou can even have dictionaries of dictionaries. They’re quite useful, in fact.\n\nfast_food = { \"McAwful\" : { \"address\" : \"1012 Western Blvd\",\\\n                            \"sanitation\" : 92} ,\\\n            \"Davids\" : { \"address\" : \"201 S Fayetteville St\",\\\n                         \"sanitation\" : 99.5 } }\n\nprint (fast_food[\"Davids\"][\"sanitation\"])\n\n99.5\n\n\nDictionaries give us the beginnings of a database. It’s not as powerful as a “real” database, but it’s good enough for a lot of things. Of course, a dictionary is like any iother variable: it only lasts as long as your program is running. You would have to combine a dictionary with some file access to have any permanent storage.\nWhat happens if we try to look up a key:value pair, and the key isn’t in the dictionary? Let’s see!\n\nprint(fast_food[\"Ruth's Chris\"])\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 print(fast_food[\"Ruth's Chris\"])\n\nKeyError: \"Ruth's Chris\"\n\n\n\nYeah, we expected that by now, didn’t we? It threw a “KeyError” exception. What should we do about this? We could always wrap the access up in a try/except structure to catch the KeyError, but this is such a common problem that Python gives us a friendlier way to do it: the in operator.\nRemember using in to see if something was in a string? This is philosophically similar. Let’s try it:\n\nif \"Ruth's Chris\" in fast_food:\n    print(\"Surprised to see such an expensive place here!\")\nelse:\n    print(\"that's a relief, actually.\")\n\nthat's a relief, actually.\n\n\nAdding to a dictionary is even easier than adding to a list. All you do is just act like the key was already there and assign it a value:\n\nprint(favorite_food)\nprint()\nfavorite_food[\"Dan\"] = 'Fish'\nprint(\"Now we have:\")\nprint(favorite_food)\n\n{'Alice': 'Apple Pie', 'Bob': 'Ice Cream', 'Charlie': 'Pizza', 'Dan': 'Fish'}\n\nNow we have:\n{'Alice': 'Apple Pie', 'Bob': 'Ice Cream', 'Charlie': 'Pizza', 'Dan': 'Fish'}\n\n\nWhat happens if we try to overwrite some data?\n\nfavorite_food[\"Charlie\"] = \"Soup\"\nprint(favorite_food)\n\n{'Alice': 'Apple Pie', 'Bob': 'Ice Cream', 'Charlie': 'Soup', 'Dan': 'Fish'}\n\n\nWe can change what is stored in the “value” part of the key:value pair any time we want. We can’t change the key, though. At least, we can’t change it directly. We can always delete the existing key:value pair and replace it with a new one. Let’s say Charlie really wants to be known as Chuck. He has his reasons. So let’s fix the favorite_food dictionary:\n\nmunchie = favorite_food[\"Charlie\"]\ndel favorite_food[\"Charlie\"]\nfavorite_food[\"Chuck\"]=munchie\nprint(favorite_food)\n\nWhat we did to accomplish that was 1. Look up Charlie’s favorite food and save that value. 2. use the built-in del operator to remove Charlie as a key and whatever value was associated with him. 3. Insert a new key:value pair whose key is “Chuck” and whose value is whatever we looked up before.\nSince every other Python data type that holds more than one thing can work with the built-in len() function, it stands to reason that dictionaries can, too. And as you would imagine, len() returns the number of entries in the dictionary.\n\nlen(favorite_food)\n\n4\n\n\n\nLooping and Iteration\n\nA dictionary is another type of iterable. This means we can write loops that traverse the entire dictionary, start to finish, and do something useful.\n\nfor key in favorite_food:\n    print(key)\n\nAlice\nBob\nDan\nChuck\n\n\nNotice that a traversal of a dictionary retrieves the keys. If you want to retrieve the values, just use the keys to look up the values.\nfor key in favorite_food: print(favorite_food[key])"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.out.html",
    "href": "preliminaries/PRE100/PE100-05Functions.out.html",
    "title": "PE100-05: Functions",
    "section": "",
    "text": "Functions in Python are very, very similar to functions in mathematics. Our functions take one or more input values and transform them into precisely one output. Let’s start with an example.\ndef inductiveReactance(l, f):\n    reactance = 2 * 3.14159 * f * l\n    return reactance\n\nprint (inductiveReactance(1e-3, 2e6))\n\n12566.36\nThe above code defines a function named “inductiveReactance” that accepts two input parameters. The first one, l, is the amount of inductance a coil has in henrys. The second one, f, is the frequency of interest (in hertz). We can call that function with parameters of one millihenry and two megahertz. The function computes the value 12566.36 (the unit is ohms) and returns that to the code that called it. In this case, it was a print statement that called it.\nTake a look at the first line. The very first thing is the keyword def (shortened from the word “define”). After the “def” is where you specify the name of the new function you want to create. In this case, it’s “inductiveReactance”. Next is a list of names of parameters, enclosed in parentheses. In our example, the parameters are “l” and “f”. Finally at the end of the line is a colon.\nOnce that first line is done, the next step is to write the body of the function. Just like an “if”, “while”, or “for” statement, the code block has to be indented consistently. Our example function computes the reactance of the device in question. On the last line of the function, the return statement is how the function sends its computed value back to the code that called the function in the first place. Every function should have at least one return statement. I won’t get drawn into this debate: some say a function should have precisely one return statement and utilize whatever logical means necessary to make sure that all code paths eventually lead to it. Others say it’s not a problem at all for a function to have multiple return statements (and hence multiple ways for a function to end) if it makes the logic more understandable. Personally, I try to minimize the number of return statements in my functions but I’m by no means a zealot on this one. If I need seven different places to exit the function and return a value then so be it."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.out.html#encapsulation",
    "href": "preliminaries/PRE100/PE100-05Functions.out.html#encapsulation",
    "title": "PE100-05: Functions",
    "section": "Encapsulation",
    "text": "Encapsulation\nFunctions are useful in programming for the same reason they’re useful in math - ours encapsulate a chunk of code so you don’t have to think about what is in it every time. Imagine how tedious it would be to write a program that needed to compute cosine in a lot of different places in the code. You could, I suppose, type in a Taylor series expansion for cosine in each of the places where we need to compute a cosign. That would be irritating, error prone, and confusing to anyone else who has to read it. Instead, we can write a function exactly once to compute cosine and then call that function from many places in our code. Once we have the function tested and debugged, we don’t have to think about it again. That frees up mental energy for more productive uses.\nFunctions can be classified into one of two types. Void Functions exist for encapsulation and don’t actually return a value. print() is an example of a void function. Value-Returning Functions, as the name strongly implies, return a value to the calling code. inductiveReactance() is an example of one.\nHere’s another example. This time, we’ll define a function that calls another function.\n\ndef squared(x):\n    return x ** 2\n\ndef circle_area(radius):\n    area = 3.14159 * squared(radius)\n    return area\n\n\nprint(\"Area of a circle with a radius of 2 is\", circle_area(2))\n\nArea of a circle with a radius of 2 is 12.56636\n\n\nWe defined a function to compute the area of a circle. It needed to square a number and so we decided to write a function to do that. Functions can call other functions ad infinitum. In fact, functions can even call themselves! When that happens the function is said to be recursive. Recursive functions are very useful for solving some hard problems but they’re a little beyond an introductory module like this one."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.out.html#function-and-variable-naming",
    "href": "preliminaries/PRE100/PE100-05Functions.out.html#function-and-variable-naming",
    "title": "PE100-05: Functions",
    "section": "Function (and Variable) Naming",
    "text": "Function (and Variable) Naming\nWhat kinds of names can we use for functions? The same ones we can use for variables! More specifically, * No keywords (e.g., False is invalid) * No spaces (e.g., my function is invalid) * The first character must be: * a-z, A-Z, or _ (the underscore character) * No numbers (e.g., 1st_function is invalid) * After the first character, the following are allowed: * a-z, A-Z, _, and 0-9 * No other symbols (e.g., get_room&board is invalid)\nAs a widely agreed upon best practice, names should be meaningful and be composed of lowercase characters with underscores as separators."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.out.html#function-arguments",
    "href": "preliminaries/PRE100/PE100-05Functions.out.html#function-arguments",
    "title": "PE100-05: Functions",
    "section": "Function Arguments",
    "text": "Function Arguments\nInput Parameters to functions are called arguments. They are the primary and best way to put information into a function, and definitely the way that causes the fewest problems. Arguments to a function in Python are mostly analagous to what we’re used to in math, but of course Python has some extensions.\nA function can have any number of arguments, including zero. “A function of zero arguments” might sound like a mathematician’s idea of “humor”, but it can actually make sense in programming. Sometimes you just need to encapsulate part of your code so you don’t have to worry with it again. For instance:\n\ndef say_hi():\n    print(\"==============================\")\n    print(\"==============================\")\n    print(\"Greetings, User. I'll start \")\n    print(\"loading the instrument config\")\n    print(\"files and opening connections\")\n    print(\"to them. It'll take a minute.\")\n    print(\"==============================\")\n    print(\"==============================\")\n\nsay_hi()\n\n==============================\n==============================\nGreetings, User. I'll start \nloading the instrument config\nfiles and opening connections\nto them. It'll take a minute.\n==============================\n==============================\n\n\nNow the code to print that banner is hidden away inside a function we’ll never have to look at again. Less mental clutter means fewer bugs.\nAnd for the sake of completeness, functions can also take one or more arguments:\n\ndef convert_to_miles(kilometers):\n    return kilometers * .6213712\n\ndef interesting_polynomial(a, b, c, d):\n    result = 2*(c**3) + 3.91*(c**2) + 1.1*c + d\n    return result\n\nprint(\"The race was\", convert_to_miles(10), \"miles long and my ankles were hurting the ENTIRE way.\")\n\nprint(\"The polynomial evaluates to:\", interesting_polynomial(7,4,8,1))\n\nThe race was 6.213712 miles long and my ankles were hurting the ENTIRE way.\nThe polynomial evaluates to: 1284.04\n\n\nWhen arguments are passed into a function, they become parameter variables and can be referred to inside the function just like any other variable. This handy because the variables inside a function are called local variables and they have special properties: nothing outside of the function can modify their value, they’re destroyed and re-created every time the function is called, and these local variables supercede any outside variables with the same name.\nTake a look for yourself:\n\ndef show_twice_the_wavelength(wavelength):\n    wavelength = wavelength * 2\n    print(\"Twice the wavelength is\", wavelength)\n\n# a good wavelength to listen for synchrotron radiation\n# emitted from Jupiter (the planet, not the software), in meters\nwavelength = 20\nshow_twice_the_wavelength(wavelength)\nshow_twice_the_wavelength(wavelength)\nshow_twice_the_wavelength(wavelength)\n\n    \n\nTwice the wavelength is 40\nTwice the wavelength is 40\nTwice the wavelength is 40\n\n\nDoes that seem odd to you? What happened is this: four lines from the bottom we created a variable named “wavelength” and set it to 20. We then called the function to print it out doubled. We passed the global variable “wavelength” to our function which took it as its only argument. That argument became a parameter variable that was coincidentally named “wavelength”. That “wavelength” parameter variable has nothing to do with the “wavelength” variable in the main part of the program. Our function doubles that parameter variable and prints it out. At that point, the function completes and the flow of control goes back to the main body.\nThe next time our function is called an entirely new, fresh set of variables and parameter variables is created. This is important - it means that if we call the function with the same value every time then we always get the same result. Functions are unable to save their “state”. Like a football player on a stretcher, they have no memory of what happened before.\n(OK, yes, there are ways for them to save their state. Sometimes it’s unavoidable and you just have to do it, but doing so makes more places for bugs to creep into your programs and makes it harder to understand later. Try to avoid it. We’ll talk about it later.)"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.out.html#variable-scope",
    "href": "preliminaries/PRE100/PE100-05Functions.out.html#variable-scope",
    "title": "PE100-05: Functions",
    "section": "Variable Scope",
    "text": "Variable Scope\nThe degree to which your programs can “see” a variable is called scope. There are two levels of scope in most Python programming:\n\nGlobal Scope\n\nDefined in main Python file\nOutside of ANY function\nTry to avoid these!\n\nConsidered poor design\nDangerous to use: any part of the program anywhere can change these\nBug Magnet!\n\n\nLocal Scope\n\nVariables defined within a function\nOnly visible and useable from inside their own function!\nUse these if at all possible.\n\n\nThe danger in global variables comes from two things. The first is the fact that the value can be changed anywhere in your program, either in the main program or inside of a function, and it’s devilishly hard to keep track of where that might be.\nThe second danger is more subtle. When a function saves a value into a global variable, the function is now said to have side effects. Side effects break the idea of isolation that functions are meant to give us. Imagine a mathematical function, such as tangent, if it had side effects. Calling tan(.0125) would not only result in the tangent of .0125, but it would have some other effect on some unrelated part of math. Imagine if calling tan caused your coordinate system to change every time? That would be insane.\nIt gets worse, though. What if our tangent function also read from a global variable and changed its behavior based on that. Then each time we called tan(.0125) we might get a different value.\nIn other words, we basically broke math.\nSimilarly, when we write programs, if our functions have side effects then we’ve complicated them tremendously. And more complication means more places for bugs to sneak into our code and they’ll also be harder to find.\nAs an aside, there is a style of programming that eliminates global variables and, to an extent, even local variables. It’s called functional programming, and Python has some support for that style. There is usually more than one way to do anything in Python, and experienced Pythonistas will usually try to choose the most Pythonic way. Part of being in Pythonic style means to use (at least partially) a functional style."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.out.html#constants",
    "href": "preliminaries/PRE100/PE100-05Functions.out.html#constants",
    "title": "PE100-05: Functions",
    "section": "Constants",
    "text": "Constants\nThere is an exception to the “no globals” rule: Constants. Just like in math, a constant is given a value once and never changed again. “Never changing” means “no side effects” so everything is OK. It is good practice to define your constants using ALL CAPITAL LETTERS.\n\nPLANCK = 6.626e-34\n\ndef photon_energy(freq):\n    gumption = PLANCK*freq\n    return gumption\n\nprint(photon_energy(3e14))\n\n1.9878e-19"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.out.html#abstraction",
    "href": "preliminaries/PRE100/PE100-05Functions.out.html#abstraction",
    "title": "PE100-05: Functions",
    "section": "Abstraction",
    "text": "Abstraction\nA valuable property of functions is how they isolate the code and variables inside of them from being manipulated elsewhere in your software. A consequence of that is their ability to “hide” detail from us. We’ve already talked about writing a function, debugging it, and never having to look at the code inside of it again. What is every bit as useful, if not more so, is using functions to provide abstraction.\nAbstraction is something we’ve used every day even if we haven’t thought it. Remember learning math? You started off counting things, and yes, that counts as math. If you had four bottle caps in one hand and three in the other, you could toss them all on the table, count them, and know that you have seven in total.\nThere are two problems with having to count everything. One is that the amount of stuff can get big in a hurry. Try using two hands and table to count sand grains. The other problem is that if there are any insights to be had, it’s hard to find them when you’re stuck down in the details. Fortunately, we learned arithmetic.\nArithmetic is great. We don’t have to deal with handfuls of stuff anymore. We can just use numbers and operators and get an answer without a bunch of messing around. We can start to see patterns we never would have just tossing bottle caps on the table. If we need to add 12 to something, we can instead add 10 and then add 2 more. This is so handy. Of course, it would be nice if we could just do something to analyze entire families of arithmetic problems.\nAlgebra lets us analyze entire families of arithmetic problems. We don’t have to fool with numbers if we don’t have to - we can just substitute variables in their place. We’ve hidden some of the complexity, like the petty little details of numbers, and abstracted that complexity away.\nSimilarly, a lot of problem solving is perfectly amenable to using abstraction. Let’s write a bit of code to run an experiment…\n\ndef run_experiment():\n    safe=is_it_safe_to_run()\n    if safe == True:\n        light_em_up()\n        put_facility_back_in_a_safe_state()\n        print(\"Better than Ghostbusters, huh?\")\n        \n\nThat function is a (admittedly fanciful) representation of running an experiment. It makes sense, anyone can understand it, and if there’s a bug in there then it’s going to be really obvious. The only problem: if we try to run it, it’ll crash because those other functions haven’t been defined yet. Shall we fix that?\n\ndef is_it_safe_to_run():\n    if badges_swiped_in() == 0 and shutter_closed() and not red_light_illuminated():\n        return True\n    else:\n        return False\n\ndef shutter_closed():\n    # put some code to interface with the solenoid sense switch here\n    return True;\n\ndef red_light_illuminated():\n    # more code, this time to see if the light is on...\n    return False\n\ndef badges_swiped_in():\n    # do some database lookups or something to see if we\n    # think anyone is still in the room.\n    return 0;\n\n\ndef light_em_up():\n    turn_on_red_light()\n    high_voltage(True)\n    shutter_open()\n    # a few seconds delay here, perhaps?\n\ndef put_facility_back_in_safe_state():\n    shutter_closed()\n    high_voltage(False)\n    turn_off_red_light()\n\nNotice how the program is broken up into several functions? The best part is that you don’t have to keep everything in your head. All you have to remember is the part you’re working on. Smaller pieces, fewer bugs."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.out.html#modules",
    "href": "preliminaries/PRE100/PE100-05Functions.out.html#modules",
    "title": "PE100-05: Functions",
    "section": "Modules",
    "text": "Modules\nOne reason Python has become so popular is the sheer amount of code that has been written in it and made available for public use. We’ve seen a few functions already that were built in to Python - int(), float(), and str(), for example - but there are many tens of thousands of modules that are freely available for use in your own software. Just picking five common ones at random:\n\nmath\nrandom\nos\nPyMySql\npsycopg\n\nThe first two contain functions for general-purpose math and for producing random numbers. The “os” module interfaces Python with the operating system the code is running on. PyMySql and psycopg provide connectivity to relational databases.\nRemember at the beginning of this lesson when we wrote a function to calculate inductive reactance? I put the value of pi in there as 3.14159, but that really isn’t anywhere near enough digits for some problems. Let’s fix that:\n\nimport math\nprint(math.pi)\n\n3.141592653589793\n\n\nThere are two things to note here. First, the keyword import is used to tell Python to go find a module with the right name and load it. The name we want it to find is the word right after the import. And secondly, just looking at the output we can see that there are a lot more digits than when we did something by hand in our Inductive Impedance example (top of this page). In general, using a module that was (a) written by someone else and (b) is widely used and has been checked by a lot of people is going to avoid a lot of bugs. For instance, I would never code my own Fast Fourier Transform. Instead, I would use the one in the “numpy” module. I know how easy it is to make a mistake and I trust their work a lot more than my own. They have tens or hundreds of thousands of users and scores of developers. I have… a copy of Numerical Recipes that’s old enough to run for President.\nSince we used the “math” module already, here’s a very incomplete list of what is in there: * sin(), cos(), tan(), acos(), asin(), atan()… - “acos” is “arc cosine”, etc. * log(), log10(), sqrt() - square root * radians(), degrees() - converts between them\nAnd lots more stuff. How do you know what’s in it? Go to the online documentation: https://docs.python.org/3/library/math.html\n\nRandom Numbers\nAnother module that is heavily used is “random”. It generates random numbers, yes, but it can also do things like take a list of things and shuffle them randomly.\n\nimport random\ninteger_number = random.randint(10,100)\nreal_number = random.random()\n\nprint(\"The random integer between 10 and 100 was:\", integer_number)\nprint(\"The random float between 0 and 1 is:\", real_number)\n\nThe random integer between 10 and 100 was: 20\nThe random float between 0 and 1 is: 0.6474502367565016\n\n\nThere are more functions available in the “random” module, including ones to select a real number from a non-uniform distribution. Take a look at https://docs.python.org/3/library/random.html\nHere’s a slightly more complicated example:\n\n# for 25 hypothetical proposals, use random() to decide\n# if it gets funded.\n\nfor proposal in range(0,25):\n    if random.random() &lt; 0.12:\n        print(\"Proposal number\", proposal,\"was funded!\")\n    else:\n        print(\"Don't feel bad... proposal number\", researcher, \"didn't get funded either.\")\n\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nProposal number 23 was funded!\nDon't feel bad... proposal number 24 didn't get funded either.\n\n\n\nLet’s try out what we’ve learned so far. Use the next code cell to write a bit of Python that simulates rolling a pair of dice and adds the two values. Print the value out.\nLet’s add to that… add a loop so that we keep doing that over and over until we get the same sum twice in a row. Some questions to ask yourself are “What kind of loop do I need?” and “How can I compare what happened between two different loop iterations?”"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.html",
    "href": "preliminaries/PRE100/PE100-05Functions.html",
    "title": "PE100-05: Functions",
    "section": "",
    "text": "Functions in Python are very, very similar to functions in mathematics. Our functions take one or more input values and transform them into precisely one output. Let’s start with an example.\ndef inductiveReactance(l, f):\n    reactance = 2 * 3.14159 * f * l\n    return reactance\n\nprint (inductiveReactance(1e-3, 2e6))\n\n12566.36\nThe above code defines a function named “inductiveReactance” that accepts two input parameters. The first one, l, is the amount of inductance a coil has in henrys. The second one, f, is the frequency of interest (in hertz). We can call that function with parameters of one millihenry and two megahertz. The function computes the value 12566.36 (the unit is ohms) and returns that to the code that called it. In this case, it was a print statement that called it.\nTake a look at the first line. The very first thing is the keyword def (shortened from the word “define”). After the “def” is where you specify the name of the new function you want to create. In this case, it’s “inductiveReactance”. Next is a list of names of parameters, enclosed in parentheses. In our example, the parameters are “l” and “f”. Finally at the end of the line is a colon.\nOnce that first line is done, the next step is to write the body of the function. Just like an “if”, “while”, or “for” statement, the code block has to be indented consistently. Our example function computes the reactance of the device in question. On the last line of the function, the return statement is how the function sends its computed value back to the code that called the function in the first place. Every function should have at least one return statement. I won’t get drawn into this debate: some say a function should have precisely one return statement and utilize whatever logical means necessary to make sure that all code paths eventually lead to it. Others say it’s not a problem at all for a function to have multiple return statements (and hence multiple ways for a function to end) if it makes the logic more understandable. Personally, I try to minimize the number of return statements in my functions but I’m by no means a zealot on this one. If I need seven different places to exit the function and return a value then so be it."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.html#encapsulation",
    "href": "preliminaries/PRE100/PE100-05Functions.html#encapsulation",
    "title": "PE100-05: Functions",
    "section": "Encapsulation",
    "text": "Encapsulation\nFunctions are useful in programming for the same reason they’re useful in math - ours encapsulate a chunk of code so you don’t have to think about what is in it every time. Imagine how tedious it would be to write a program that needed to compute cosine in a lot of different places in the code. You could, I suppose, type in a Taylor series expansion for cosine in each of the places where we need to compute a cosign. That would be irritating, error prone, and confusing to anyone else who has to read it. Instead, we can write a function exactly once to compute cosine and then call that function from many places in our code. Once we have the function tested and debugged, we don’t have to think about it again. That frees up mental energy for more productive uses.\nFunctions can be classified into one of two types. Void Functions exist for encapsulation and don’t actually return a value. print() is an example of a void function. Value-Returning Functions, as the name strongly implies, return a value to the calling code. inductiveReactance() is an example of one.\nHere’s another example. This time, we’ll define a function that calls another function.\n\ndef squared(x):\n    return x ** 2\n\ndef circle_area(radius):\n    area = 3.14159 * squared(radius)\n    return area\n\n\nprint(\"Area of a circle with a radius of 2 is\", circle_area(2))\n\nArea of a circle with a radius of 2 is 12.56636\n\n\nWe defined a function to compute the area of a circle. It needed to square a number and so we decided to write a function to do that. Functions can call other functions ad infinitum. In fact, functions can even call themselves! When that happens the function is said to be recursive. Recursive functions are very useful for solving some hard problems but they’re a little beyond an introductory module like this one."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.html#function-and-variable-naming",
    "href": "preliminaries/PRE100/PE100-05Functions.html#function-and-variable-naming",
    "title": "PE100-05: Functions",
    "section": "Function (and Variable) Naming",
    "text": "Function (and Variable) Naming\nWhat kinds of names can we use for functions? The same ones we can use for variables! More specifically, * No keywords (e.g., False is invalid) * No spaces (e.g., my function is invalid) * The first character must be: * a-z, A-Z, or _ (the underscore character) * No numbers (e.g., 1st_function is invalid) * After the first character, the following are allowed: * a-z, A-Z, _, and 0-9 * No other symbols (e.g., get_room&board is invalid)\nAs a widely agreed upon best practice, names should be meaningful and be composed of lowercase characters with underscores as separators."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.html#function-arguments",
    "href": "preliminaries/PRE100/PE100-05Functions.html#function-arguments",
    "title": "PE100-05: Functions",
    "section": "Function Arguments",
    "text": "Function Arguments\nInput Parameters to functions are called arguments. They are the primary and best way to put information into a function, and definitely the way that causes the fewest problems. Arguments to a function in Python are mostly analagous to what we’re used to in math, but of course Python has some extensions.\nA function can have any number of arguments, including zero. “A function of zero arguments” might sound like a mathematician’s idea of “humor”, but it can actually make sense in programming. Sometimes you just need to encapsulate part of your code so you don’t have to worry with it again. For instance:\n\ndef say_hi():\n    print(\"==============================\")\n    print(\"==============================\")\n    print(\"Greetings, User. I'll start \")\n    print(\"loading the instrument config\")\n    print(\"files and opening connections\")\n    print(\"to them. It'll take a minute.\")\n    print(\"==============================\")\n    print(\"==============================\")\n\nsay_hi()\n\n==============================\n==============================\nGreetings, User. I'll start \nloading the instrument config\nfiles and opening connections\nto them. It'll take a minute.\n==============================\n==============================\n\n\nNow the code to print that banner is hidden away inside a function we’ll never have to look at again. Less mental clutter means fewer bugs.\nAnd for the sake of completeness, functions can also take one or more arguments:\n\ndef convert_to_miles(kilometers):\n    return kilometers * .6213712\n\ndef interesting_polynomial(a, b, c, d):\n    result = 2*(c**3) + 3.91*(c**2) + 1.1*c + d\n    return result\n\nprint(\"The race was\", convert_to_miles(10), \"miles long and my ankles were hurting the ENTIRE way.\")\n\nprint(\"The polynomial evaluates to:\", interesting_polynomial(7,4,8,1))\n\nThe race was 6.213712 miles long and my ankles were hurting the ENTIRE way.\nThe polynomial evaluates to: 1284.04\n\n\nWhen arguments are passed into a function, they become parameter variables and can be referred to inside the function just like any other variable. This handy because the variables inside a function are called local variables and they have special properties: nothing outside of the function can modify their value, they’re destroyed and re-created every time the function is called, and these local variables supercede any outside variables with the same name.\nTake a look for yourself:\n\ndef show_twice_the_wavelength(wavelength):\n    wavelength = wavelength * 2\n    print(\"Twice the wavelength is\", wavelength)\n\n# a good wavelength to listen for synchrotron radiation\n# emitted from Jupiter (the planet, not the software), in meters\nwavelength = 20\nshow_twice_the_wavelength(wavelength)\nshow_twice_the_wavelength(wavelength)\nshow_twice_the_wavelength(wavelength)\n\n    \n\nTwice the wavelength is 40\nTwice the wavelength is 40\nTwice the wavelength is 40\n\n\nDoes that seem odd to you? What happened is this: four lines from the bottom we created a variable named “wavelength” and set it to 20. We then called the function to print it out doubled. We passed the global variable “wavelength” to our function which took it as its only argument. That argument became a parameter variable that was coincidentally named “wavelength”. That “wavelength” parameter variable has nothing to do with the “wavelength” variable in the main part of the program. Our function doubles that parameter variable and prints it out. At that point, the function completes and the flow of control goes back to the main body.\nThe next time our function is called an entirely new, fresh set of variables and parameter variables is created. This is important - it means that if we call the function with the same value every time then we always get the same result. Functions are unable to save their “state”. Like a football player on a stretcher, they have no memory of what happened before.\n(OK, yes, there are ways for them to save their state. Sometimes it’s unavoidable and you just have to do it, but doing so makes more places for bugs to creep into your programs and makes it harder to understand later. Try to avoid it. We’ll talk about it later.)"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.html#variable-scope",
    "href": "preliminaries/PRE100/PE100-05Functions.html#variable-scope",
    "title": "PE100-05: Functions",
    "section": "Variable Scope",
    "text": "Variable Scope\nThe degree to which your programs can “see” a variable is called scope. There are two levels of scope in most Python programming:\n\nGlobal Scope\n\nDefined in main Python file\nOutside of ANY function\nTry to avoid these!\n\nConsidered poor design\nDangerous to use: any part of the program anywhere can change these\nBug Magnet!\n\n\nLocal Scope\n\nVariables defined within a function\nOnly visible and useable from inside their own function!\nUse these if at all possible.\n\n\nThe danger in global variables comes from two things. The first is the fact that the value can be changed anywhere in your program, either in the main program or inside of a function, and it’s devilishly hard to keep track of where that might be.\nThe second danger is more subtle. When a function saves a value into a global variable, the function is now said to have side effects. Side effects break the idea of isolation that functions are meant to give us. Imagine a mathematical function, such as tangent, if it had side effects. Calling tan(.0125) would not only result in the tangent of .0125, but it would have some other effect on some unrelated part of math. Imagine if calling tan caused your coordinate system to change every time? That would be insane.\nIt gets worse, though. What if our tangent function also read from a global variable and changed its behavior based on that. Then each time we called tan(.0125) we might get a different value.\nIn other words, we basically broke math.\nSimilarly, when we write programs, if our functions have side effects then we’ve complicated them tremendously. And more complication means more places for bugs to sneak into our code and they’ll also be harder to find.\nAs an aside, there is a style of programming that eliminates global variables and, to an extent, even local variables. It’s called functional programming, and Python has some support for that style. There is usually more than one way to do anything in Python, and experienced Pythonistas will usually try to choose the most Pythonic way. Part of being in Pythonic style means to use (at least partially) a functional style."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.html#constants",
    "href": "preliminaries/PRE100/PE100-05Functions.html#constants",
    "title": "PE100-05: Functions",
    "section": "Constants",
    "text": "Constants\nThere is an exception to the “no globals” rule: Constants. Just like in math, a constant is given a value once and never changed again. “Never changing” means “no side effects” so everything is OK. It is good practice to define your constants using ALL CAPITAL LETTERS.\n\nPLANCK = 6.626e-34\n\ndef photon_energy(freq):\n    gumption = PLANCK*freq\n    return gumption\n\nprint(photon_energy(3e14))\n\n1.9878e-19"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.html#abstraction",
    "href": "preliminaries/PRE100/PE100-05Functions.html#abstraction",
    "title": "PE100-05: Functions",
    "section": "Abstraction",
    "text": "Abstraction\nA valuable property of functions is how they isolate the code and variables inside of them from being manipulated elsewhere in your software. A consequence of that is their ability to “hide” detail from us. We’ve already talked about writing a function, debugging it, and never having to look at the code inside of it again. What is every bit as useful, if not more so, is using functions to provide abstraction.\nAbstraction is something we’ve used every day even if we haven’t thought it. Remember learning math? You started off counting things, and yes, that counts as math. If you had four bottle caps in one hand and three in the other, you could toss them all on the table, count them, and know that you have seven in total.\nThere are two problems with having to count everything. One is that the amount of stuff can get big in a hurry. Try using two hands and table to count sand grains. The other problem is that if there are any insights to be had, it’s hard to find them when you’re stuck down in the details. Fortunately, we learned arithmetic.\nArithmetic is great. We don’t have to deal with handfuls of stuff anymore. We can just use numbers and operators and get an answer without a bunch of messing around. We can start to see patterns we never would have just tossing bottle caps on the table. If we need to add 12 to something, we can instead add 10 and then add 2 more. This is so handy. Of course, it would be nice if we could just do something to analyze entire families of arithmetic problems.\nAlgebra lets us analyze entire families of arithmetic problems. We don’t have to fool with numbers if we don’t have to - we can just substitute variables in their place. We’ve hidden some of the complexity, like the petty little details of numbers, and abstracted that complexity away.\nSimilarly, a lot of problem solving is perfectly amenable to using abstraction. Let’s write a bit of code to run an experiment…\n\ndef run_experiment():\n    safe=is_it_safe_to_run()\n    if safe == True:\n        light_em_up()\n        put_facility_back_in_a_safe_state()\n        print(\"Better than Ghostbusters, huh?\")\n        \n\nThat function is a (admittedly fanciful) representation of running an experiment. It makes sense, anyone can understand it, and if there’s a bug in there then it’s going to be really obvious. The only problem: if we try to run it, it’ll crash because those other functions haven’t been defined yet. Shall we fix that?\n\ndef is_it_safe_to_run():\n    if badges_swiped_in() == 0 and shutter_closed() and not red_light_illuminated():\n        return True\n    else:\n        return False\n\ndef shutter_closed():\n    # put some code to interface with the solenoid sense switch here\n    return True;\n\ndef red_light_illuminated():\n    # more code, this time to see if the light is on...\n    return False\n\ndef badges_swiped_in():\n    # do some database lookups or something to see if we\n    # think anyone is still in the room.\n    return 0;\n\n\ndef light_em_up():\n    turn_on_red_light()\n    high_voltage(True)\n    shutter_open()\n    # a few seconds delay here, perhaps?\n\ndef put_facility_back_in_safe_state():\n    shutter_closed()\n    high_voltage(False)\n    turn_off_red_light()\n\nNotice how the program is broken up into several functions? The best part is that you don’t have to keep everything in your head. All you have to remember is the part you’re working on. Smaller pieces, fewer bugs."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-05Functions.html#modules",
    "href": "preliminaries/PRE100/PE100-05Functions.html#modules",
    "title": "PE100-05: Functions",
    "section": "Modules",
    "text": "Modules\nOne reason Python has become so popular is the sheer amount of code that has been written in it and made available for public use. We’ve seen a few functions already that were built in to Python - int(), float(), and str(), for example - but there are many tens of thousands of modules that are freely available for use in your own software. Just picking five common ones at random:\n\nmath\nrandom\nos\nPyMySql\npsycopg\n\nThe first two contain functions for general-purpose math and for producing random numbers. The “os” module interfaces Python with the operating system the code is running on. PyMySql and psycopg provide connectivity to relational databases.\nRemember at the beginning of this lesson when we wrote a function to calculate inductive reactance? I put the value of pi in there as 3.14159, but that really isn’t anywhere near enough digits for some problems. Let’s fix that:\n\nimport math\nprint(math.pi)\n\n3.141592653589793\n\n\nThere are two things to note here. First, the keyword import is used to tell Python to go find a module with the right name and load it. The name we want it to find is the word right after the import. And secondly, just looking at the output we can see that there are a lot more digits than when we did something by hand in our Inductive Impedance example (top of this page). In general, using a module that was (a) written by someone else and (b) is widely used and has been checked by a lot of people is going to avoid a lot of bugs. For instance, I would never code my own Fast Fourier Transform. Instead, I would use the one in the “numpy” module. I know how easy it is to make a mistake and I trust their work a lot more than my own. They have tens or hundreds of thousands of users and scores of developers. I have… a copy of Numerical Recipes that’s old enough to run for President.\nSince we used the “math” module already, here’s a very incomplete list of what is in there: * sin(), cos(), tan(), acos(), asin(), atan()… - “acos” is “arc cosine”, etc. * log(), log10(), sqrt() - square root * radians(), degrees() - converts between them\nAnd lots more stuff. How do you know what’s in it? Go to the online documentation: https://docs.python.org/3/library/math.html\n\nRandom Numbers\nAnother module that is heavily used is “random”. It generates random numbers, yes, but it can also do things like take a list of things and shuffle them randomly.\n\nimport random\ninteger_number = random.randint(10,100)\nreal_number = random.random()\n\nprint(\"The random integer between 10 and 100 was:\", integer_number)\nprint(\"The random float between 0 and 1 is:\", real_number)\n\nThe random integer between 10 and 100 was: 20\nThe random float between 0 and 1 is: 0.6474502367565016\n\n\nThere are more functions available in the “random” module, including ones to select a real number from a non-uniform distribution. Take a look at https://docs.python.org/3/library/random.html\nHere’s a slightly more complicated example:\n\n# for 25 hypothetical proposals, use random() to decide\n# if it gets funded.\n\nfor proposal in range(0,25):\n    if random.random() &lt; 0.12:\n        print(\"Proposal number\", proposal,\"was funded!\")\n    else:\n        print(\"Don't feel bad... proposal number\", researcher, \"didn't get funded either.\")\n\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nProposal number 23 was funded!\nDon't feel bad... proposal number 24 didn't get funded either.\n\n\n\nLet’s try out what we’ve learned so far. Use the next code cell to write a bit of Python that simulates rolling a pair of dice and adds the two values. Print the value out.\nLet’s add to that… add a loop so that we keep doing that over and over until we get the same sum twice in a row. Some questions to ask yourself are “What kind of loop do I need?” and “How can I compare what happened between two different loop iterations?”"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.html",
    "href": "preliminaries/PRE100/PE100-04Repetition.html",
    "title": "PE100-04: Repetition",
    "section": "",
    "text": "We started off learning Python with just simple lists of statements…\ntemperature = 100\nprint(\"It's\", temperature, \"celsius\")\nfaren_t = temperature * (9/5) + 32\nprint(\"or\", faren_t, \"in pagan units.\")\n\nIt's 100 celsius\nor 212.0 in pagan units.\nThen we added the if statement so we could control whether or not certain statements would execute or not:\nif temperature &gt;= 100:\n    print(\"Good chance it's boiling.\")\nelif temperature &gt; 3000:\n    print(\"Odds are it's plasma by now.\")\nelse:\n    print(\"You could probably run the experiment and it might even work.\")\n\nGood chance it's boiling.\nIn both of these cases, the code blocks only run once.\nThe problem is, sometimes we need things to run repeatedly. We want to look up all of the readings from an experiment or we need to compute the properties of something over dozens of temperatures each at dozens of pressures.\nPython gives us two different ways to make our programs repeat things in a loop.\nLet’s start with the while loop."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.html#while-loops",
    "href": "preliminaries/PRE100/PE100-04Repetition.html#while-loops",
    "title": "PE100-04: Repetition",
    "section": "While Loops",
    "text": "While Loops\nThe syntax of a while loop looks a bit like an if statement. Take a look:\n\ninstrument = 1\nwhile instrument &lt;= 2:\n   print(\"Looking at instrument number\", instrument)\n   print(\"and then maybe we'll look at the next one.\")\n   instrument = instrument + 1\nprint(\"Done with all that looping.\")\nprint(\"...and ready to do something else now.\")\n\nLooking at instrument number 1\nand then maybe we'll look at the next one.\nLooking at instrument number 2\nand then maybe we'll look at the next one.\nDone with all that looping.\n...and ready to do something else now.\n\n\nHere’s what the above code does. First, it creates a variable named “instrument” and sets it to 1. Then it goes into the while loop. The first time through, it checks to see if instrument is less than or equal to 2. It is (because we set it to 1 just a moment ago) so the while loop will execute the code block. This block prints out two lines and then it adds 1 to instrument. That means instrument now equals 2.\nThe second time through the loop, instrument equals 2. That satisfies the conditional statement of the while loop (2 is less than or equal to 2) so the code block runs again. Two more lines are printed out and then instrument is incremented one more time.\nThe while loop runs for a third time now. This time, 3 is not less than or equal to 2, so the conditional statement is false. This means the while loop is done - it won’t run its code block again, and the flow of control will go on to the next line after the while loop. It will run the two print statements explaining that the looping is over and it can go on to other tasks.\nLet’s look at another example. Let’s print out all the powers of two that are less than 928.\n\npower=0\ntwo_to_the_power = 2**power\n\nwhile two_to_the_power &lt; 928:  # Totally not Porsche related.\n    print(\"2 to the\", power,\"equals\",two_to_the_power)\n    power = power+1\n    two_to_the_power = 2**power\nprint(\"2 to the\", power,\"is too big.\")\n\n2 to the 0 equals 1\n2 to the 1 equals 2\n2 to the 2 equals 4\n2 to the 3 equals 8\n2 to the 4 equals 16\n2 to the 5 equals 32\n2 to the 6 equals 64\n2 to the 7 equals 128\n2 to the 8 equals 256\n2 to the 9 equals 512\n2 to the 10 is too big.\n\n\nDid you notice I sneaked something in there we haven’t talked about yet? See the “#” character on the line with the while statement? That indicates the rest of the line is a comment. Python will totally ignore it. It’s handy for leaving little notes to yourself, like “why did I choose 928 there when I could have put 944?” This is very, very important when writing full-fledged, standalone programs. If you don’t leave some notes for yourself, you’ll never remember what you were thinking when you go back to that code six months from now. Also, the next person who comes along and has to change something in your code will greatly appreciate the hints.\nLeaving comments in the code isn’t as big a deal in Jupyter notebooks… you can write rather substantial notes in a Markdown cell complete with boldface, italics, and whatever other fanciness you desire. On the other hand, it’s also nice to be able to leave your comments in the just the right place in the code so it flows effortlessly through your comprehension as you read it. Let experience and personal opinion be your guide here."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.html#reading-information-from-the-outside-world",
    "href": "preliminaries/PRE100/PE100-04Repetition.html#reading-information-from-the-outside-world",
    "title": "PE100-04: Repetition",
    "section": "Reading information from the outside world",
    "text": "Reading information from the outside world\nNotice that in both of those cases, we actually did know how many times the loop would run. We know that 2 to the 9th is 512 and so we know the while loop will only run that far. In fact, in every example we’ve had so far we’ve know what the output will be because we always have the same inputs. Computer software wouldn’t be terribly interesting if it could only run specific, known, canned inputs. Fortunately, Python gives us several ways to bring data into our programs.\nThe simplest way to bring data into a Python program is to edit the program and change the values we assign to variables. This is sort of the reducto ad absurdum method, but honestly it isn’t a bad way to handle very small amounts of input. It’s even easier in Jupyter notebooks since the code is just sitting there looking at us, waiting to be edited. For values that aren’t going to change very often (your name, perhaps, or the chargeback account number for using some instrument, for instance) then just assigning a value to a variable and editing it every once and a while is a fine way to go.\nAnother way to get data into a Python program is to read it in from where the user is running the program. For doing this, Python provides a function called “input” which takes an optional argument, specifically a string that is printed as a prompt. Python then waits for the user to type something as a response. When they do, that string is returned to the calling program. Here’s a simple example:\n\nyour_name = input(\"Please enter your name\")\nprint(\"Hello,\", your_name)\n\nPlease enter your name Erik\n\n\nHello, Erik\n\n\nWhen the above code runs, the prompt “Please enter your name” is displayed right below the code cell and a text entry box is placed beside it. When you enter your name, it greets you.\nIf we were running this tiny little snippet of code as a regular program, the interaction would be in the terminal emulator window that we ran the program in. Because this is running in Jupyter, though, the interaction is directly in the notebook. The prompt and the entry blank occur just below the running code cell.\nWhat will happen when we run the following?\n\nresponse = input(\"Enter a number between 4 and 8\")\nnew_value = response + 6.5\nprint(new_value)\n\nEnter a number between 4 and 8 5.25\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In [4], line 2\n      1 response = input(\"Enter a number between 4 and 8\")\n----&gt; 2 new_value = response + 6.5\n      3 print(new_value)\n\nTypeError: can only concatenate str (not \"float\") to str\n\n\n\nWow! Python couldn’t run that and it “threw an error”. We’ll examine Python’s error handling facilities later, but for now we’ll just assume that means it came to a screeching halt. Looking at the error message, it seems there is some problem with trying to add a real number (a floting point number) to a string."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.html#type-casting",
    "href": "preliminaries/PRE100/PE100-04Repetition.html#type-casting",
    "title": "PE100-04: Repetition",
    "section": "Type Casting",
    "text": "Type Casting\ninput() prompts the user and returns the string they entered, but what if we want the user to enter a number? What do we do then? The answer is we’ll use a process known as type casting. The act of type casting is no more than converting information from one type to another.\nThere are three very useful functions for type casting: int(), float(), and str(). Let’s see them in action…\n\n# three conversions:\n\n# first, string to float:\nthe_sum = 6.554 + float(\"9.9\")\nprint(the_sum)\n\n# next, string to integer:\nthe_integer_number = int(\"34543456\")\nprint(the_integer_number)\n\n#finally, integer to string:\nhandy_string = str(2+2)\nprint(handy_string)\n\n16.454\n34543456\n4\n\n\nWhat did the above do? First, it converted the string “9.9” (literally, three characters… it’s a string) to a “float” (a floating point number, some languages will call that a real number). The second example takes a string of 8 characters and interprets them as an integer. That value is what gets returned and stored in our variable. Finally, we copmute the number 4 by adding 2+2, and then we let the str() function convert that to a single character long string having just the character “4”.\nBy now we know enough to be able to ask the user for a number and get something back that we can actually do math with.\n\nuser_response = input(\"Enter a number between 17 and 34\")\nselected_number = float(user_response)\nselected_number\n\nThere’s an even easier way, though. Just like function composition worked when you took precalculus, the results of a Python function can be used as the argument to another. Hence:\n\nselected_number = float(input(\"Enter a number between 17 and 34\"))\nselected_number\n\nEnter a number between 17 and 34 26\n\n\n26.0\n\n\nSometimes, function calls can be nested really deeply. Personally, when it comes time to debug code like that I find myself printing it out and coloring each level with a different highlighter pen."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.html#putting-it-together-while-loops-to-get-user-input",
    "href": "preliminaries/PRE100/PE100-04Repetition.html#putting-it-together-while-loops-to-get-user-input",
    "title": "PE100-04: Repetition",
    "section": "Putting it together: while loops to get user input",
    "text": "Putting it together: while loops to get user input\nThe great thing about a while statement is that it can loop zero times, one, two, or twelve trillion. Best of all, we don’t have to know how many ahead of time. We could do the following:\nprint(“Computing an average.”)\nsum=0.0 counter=0 data_point = float(input(“Enter a number, or enter negative num to stop”)) while data_point &gt;= 0.0: sum = sum+data_point counter = counter+1 data_point = float(input(“Enter a number, or enter negative num to stop”))\nprint(“Average value is”, sum/counter)\nWhen we run the code above, we’re prompted to keep entering numbers until we finally enter -999. Each time it goes through the loop it keeps track of the running total of the numbers and the count of how many numbers have been entered. Once it’s done, it divides the total by the count and displays that as the average.\nLet’s step through what happens when the user enters 1, 2, 3, and -999: 1. The sum and counter variables are initialized to zero. 1. The user is prompted to enter a number, possibly a negative number to indicate no more data, and that input is type cast to a floating point number. 1. The while loop’s condition will be met any time a positive number was input (greater than or equal to zero). 1 is a positive number, so run the loop body. 1. This first time through, we’ll add the 1 that was input to our running total, which is now 1. 1. And increment the count, now equal to 1. 1. AND PROMPT THE USER FOR ANOTHER NUMBER!!! 1. Back at the while statement again, we check the condition and, yes, 2 is a positive number, so we run the loop’s code block. 1. Update the sum and count, and then… 1. PROMPT THE USER FOR ANOTHER VALUE!!! 1. Running the while statement again, the user entered 3, and 3 is positive, so the clode block will be executed. 1. Update the sum (now 6) and count (now 3). 1. Prompt for another number 1. Back at the while statement, we check and see that -999 is not a positive number, so we skip the code block and resume by running whatever follows it. 1. Having exited the while loop entirely, print out the average value by dividing sum/count.\nAll the boldface and all-capitals lines above are there to emphasize how important it is to make sure your while loop isn’t just checking the same thing over and over. If we didn’t get a new number from the user each time through, the value of data_point would never change. That would result in an infinite loop, causing Python to never be able to complete the code in that cell. If it ever happens to you, and it probably will, the “Interrupt Kernel” command on JupyterLab’s Kernel menu will stop the looping and let you get back to work.\nThe while loop is certainly versatile… it can be used any time you need to do something repeatedly. If you know how many times you need to have the code block execute, either when you write the code or when it’s running, then keep a variable that is incremented in the block every time and exit the while loop when the counter hits the right number.\nWhere while loops really shine is when it’s impossible to know ahead of time how many times the code block should run. The example above, where we keep accepting numbers until the user signals there aren’t any more, there’s no way to know how many times to execute that loop until we see a negative number. In a case like that, the while loop is the only practical solution.\nSo if while loops are so great and solve every problem, why do we need anything else? The big reason is expressiveness: they can be a little awkward to understand, especially when you’re looking at someone else’s code. Having the conditional test separated from the action that establishes when to stop makes it a little awkward to understand (or debug!) someone else’s code. This is especially true when we need to step through something by unusual increments.\nSo what are we to do in these cases?"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.html#for-loops",
    "href": "preliminaries/PRE100/PE100-04Repetition.html#for-loops",
    "title": "PE100-04: Repetition",
    "section": "For Loops",
    "text": "For Loops\nThe for loop is quite similar to the while loop. The difference is that for loops are controlled by a count whereas while loops are controlled by a condition.\nLet’s start with an example.\n\nfor the_value in range(1,4):\n    print(the_value)\n\n1\n2\n3\n\n\nThat is the simplest for loop you’ll see. Let’s look at the pieces. 1. The for statement itself 2. The name of the target variable whose value will be changing as the loop runs (“the_value” in this case”) 3. “in” - and if this reminds you of set membership then you’re on to something 4. “range()” - this is an example of an iterable, which means “something that can be stepped through”. 5. The colon… the one I forget 50% of the time. 6. The code block, in this case just a print statement.\nMost of the time, fairly close to “always”, the code block will take advantage of the target variable changing each time through. In our example, “the_value” is our target variable, as it loops through it will take on the values 1 through 3, and the code block has a print statement that uses it.\nBefore we examine the range() function, let’s take a look at another iterable. We’ll talk about lists in a later lesson, but for now we can just wave our hands around and understand enough for the moment.\n\nfor sample_weight in [123.6, 121.9, 119.4, 124.23219]:\n    print(\"The sample weighed\", sample_weight, \"grams.\")\n    if sample_weight &lt; 120:\n        print(\"Be careful! This sample might not be all you hoped for.\")\n        \n\nThe sample weighed 143.6 grams.\nThe sample weighed 141.9 grams.\nThe sample weighed 139.4 grams.\nThe sample weighed 144.23219 grams.\n\n\nYou can use the target variable as many times as you want to in the code block.\nNow let’s take a more detailed look at the range() function. In its most basic form it takes one argument - the stop value.\n\nfor i in range(4):\n    print(i)\n\n0\n1\n2\n3\n\n\nThis single-argument form starts at zero, counts up by one each time, and doesn’t include the stop value. This is different from every other programming language you’ll ever encounter. It’s just one of those things.\nWe’ve already seen the two-argument form. It takes a starting value and a stopping value, and iterates by one from the start until the last value that is less than the stop.\n\nfor i in range(7,10):\n    print(i)\n\n7\n8\n9\n\n\nAnd there’s even a three-argument form. The third argument is the amount to step by.\n\nfor i in range (12,20,3):\n    print(i)\n\n12\n15\n18\n\n\nThe step size doesn’t have to be a positive number…\n\nfor i in range(6, -3, -2):\n    print(i)\n\n6\n4\n2\n0\n-2\n\n\nIn case you’re curious, the step size cannot be zero. If you really want an infinite loop, and there are cases where it makes sense, you have to use a while loop instead.\nAs a general rule, any place where you can use an explicit value (a literal) you can use a variable. Arguments to a for loop are no exception:\n\nstart_value = int(input(\"where should we start? \"))\nend_value   = int(input(\"where should we run right up to and stop just short of it? \"))\nstep_size   = int(input(\"what should we step by? \"))\n\nfor i in range(start_value, end_value, step_size):\n    print(i)\n    \n\nwhere should we start?  13\nwhere should we run right up to and stop just short of it?  15\nwhat should we step by?  2\n\n\n13\n\n\nIf we need to do something a specific number of times, we need to pay attention to our starting and stopping conditions. I’ve messed this up so many times I know now to be careful. You’ve been warned.\n\nhow_many = int(input(\"How many numbers would you like to total up? \"))\nsum = 0\nfor i in range(1, how_many):\n    sum = sum + int(input(\"Enter a number \"))\nprint(\"They add up to\", sum)\n\nHow many numbers would you like to total up?  3\nEnter a number  4\nEnter a number  5\n\n\nThey add up to 9\n\n\nNotice something wrong? If you ask it to total 3 numbers, it only prompts for two of them. There are a couple of ways to solve this. The easiest is to just use the one-argument form of range().\n\nhow_many = int(input(\"How many numbers would you like to total up? \"))\nsum = 0\nfor i in range(how_many):\n    sum = sum + int(input(\"Enter a number \"))\nprint(\"They add up to\", sum)\n\nHow many numbers would you like to total up?  3\nEnter a number  4\nEnter a number  5\nEnter a number  6\n\n\nThey add up to 15\n\n\nThat offers a little insight into why Python has it’s funny “up to but not including” semantics: zero is a perfectly legitimate number and a very natural starting point.\nThe only problem with the single-argument method is that the values that the target variable goes through include zero. This may or may not be a problem if that value is used inside the code block. If you really need to count from one instead of zero, you can increment the stopping value:\n\nhow_many = int(input(\"How many numbers would you like to total up? \"))\nsum = 0\nfor i in range(1, how_many + 1):\n    sum = sum + int(input(\"Enter a number \"))\nprint(\"They add up to\", sum)\n\nHow many numbers would you like to total up?  3\nEnter a number  4\nEnter a number  5\nEnter a number  6\n\n\nThey add up to 15\n\n\nAnd that behaved just like we expected.\nYou may have noticed a pattern already. We frequently need to compute a new value for an existing variable. What we’ve done so far has been along the lines of grand_total = grand_total + new_reading. Python gives us a shorthand way to write that. We could instead express that as grand_total += new_reading. There is no space between the plus and equals signs. The only reason this exists is to save you some typing. As you might expect, there are a few more of these Augmented Assignment Operators…\n\n\n\nOperator\nExample\nEquivalent\n\n\n\n\n+=\ncount += 1\ncount = count + 1\n\n\n-=\nx -= offset\nx = x - offset\n\n\n*=\nproduct *= val\nproduct = product * val\n\n\n/=\ny /= 3\ny = y / 3\n\n\n%=\nval %= 2\nval = val % 2\n\n\n\nOut of all of them, += is far and away the most commonly used one."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-04Repetition.html#nested-loops",
    "href": "preliminaries/PRE100/PE100-04Repetition.html#nested-loops",
    "title": "PE100-04: Repetition",
    "section": "Nested Loops",
    "text": "Nested Loops\nYou know what’s fun to put in a loop’s code block? Another loop! Best of all, it comes in pretty handy when dealing with high-dimensional data. Plenty of algorithms rely on nested loops, too. Take a look at this:\n\nfor x in range(5):\n    for y in range(4):\n        print(\"x=\",x,\" y=\", y)\n\nx= 0  y= 0\nx= 0  y= 1\nx= 0  y= 2\nx= 0  y= 3\nx= 1  y= 0\nx= 1  y= 1\nx= 1  y= 2\nx= 1  y= 3\nx= 2  y= 0\nx= 2  y= 1\nx= 2  y= 2\nx= 2  y= 3\nx= 3  y= 0\nx= 3  y= 1\nx= 3  y= 2\nx= 3  y= 3\nx= 4  y= 0\nx= 4  y= 1\nx= 4  y= 2\nx= 4  y= 3\n\n\nWhat’s going on here? Initially, the outer loop, the one that iterates zero through four and assigns it’s value to x, runs. When it starts running its code block for the x=0 pass, the for loop for the y variable starts. ‘y’ assumes the values 0 through 3, so the first four lines printed out are for x=0, y=0, then x=0, y=1, and so on through x=0, y=3. Once that inner for loop completes, the outer for loop gets to iterate again. Now the inside for loop runs again, only this time we have x=1. That’s why the next four lines are “x=1, y=0” through “x=1, y=3”. Every time the outer loop runs another iteration, the inner loop gets to run all the way from start to finish.\nIn later lessons, we’ll have a few opportunities to play with nested loops. In fact, we’ll get to do that in the very next lesson: Functions!"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-08Lists.out.html",
    "href": "preliminaries/PRE100/PE100-08Lists.out.html",
    "title": "PE100-08: Lists",
    "section": "",
    "text": "All of the variables we’ve seen so far store exactly one value. If you set the variable “weight” to 74.5, then 74.5 is the only value there is in “weight”. Nice and simple. If we need to save several values then we can use several variables…\n\nweight_1 = 74.5\nweight_2 = 76.7\nweight_3 = 77.1\n\nAs you can imagine, this turns tedious in a hurry. What if you had a thousand values to deal with? And even if you did all of that typing, doing any kind of non-trivial computation with it would be difficult, too. We need a way to store a bunch of values, but doing it in a way that makes it easy to manipulate the whole thing as a whole or each individual value. For doing that, Python provides us with lists.\nPython is one of the few languages that support lists deep down in the language itself. Because of that, they’re easy to work with. Let’s take a look, shall we?\n\nnames = ['Alice', 'Bob', 'Candice', 'Dan']\nnames\n\n['Alice', 'Bob', 'Candice', 'Dan']\n\n\nLists are represented with square brackets [ ] at the beginning and end, and with the values inside the brackets separated by commas.\n\nodd_numbers = [1, 3, 5, 7, 9]\ningredients = ['flour', 'lard', 'baking powder', 'milk']\n\nThe values in a list don’t all have to be the same type.\n\nplaying_card = [9, 'Diamonds']\n\nA list can have any number of values, limited only by the amount of memory in the computer that is hosting the Jupyter (or JupyterLab) server. Lists are even allowed to have no values in them.\n\nempty_list = []\n\nSo far we’ve been creating lists using literal values, but we could use variables just as easily…\n\nnimh = 16\nlithiumPrimary = 2\ncarbonZinc = 6\n\nbattery_inventory = [nimh, lithiumPrimary, carbonZinc]\nprint(battery_inventory)\n\n[16, 2, 6]\n\n\nTo find out how many elements are in a list, use the len() function:\n\nnumber_of_ingredients = len(ingredients)\nprint(number_of_ingredients)\n\nprint(len(battery_inventory))\n\n4\n3\n\n\nThere are operators that act on lists. The * operator is used for repetition…\n\nmy_list = [1, 2, 3] * 2\nprint(my_list)\nmany_zeros = [0] * 25\nprint(many_zeros)\n\n[1, 2, 3, 1, 2, 3]\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n\n…and the + operator combines two lists:\n\nbig_list = my_list + many_zeros\nprint(big_list)\n\n[1, 2, 3, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n\nLists are iterables, just like the results of the range() function, so they can be iterated over using a for loop:\n\nfor name in ['David', 'Bill', 'Richard']:\n    print(name)\n\nDavid\nBill\nRichard\n\n\n\nfor ingr in ingredients * 3:\n    print(ingr)\n\nflour\nlard\nbaking powder\nmilk\nflour\nlard\nbaking powder\nmilk\nflour\nlard\nbaking powder\nmilk\n\n\nIt’s fairly common to iterate over a list for things like sums and averages.\n\ntotal = 0\nfor item in [4, 3, 4, 5]:\n    total += item\nprint(total)\n\n16\n\n\nThe above code steps its way over all of the values in the list. Each time it goes to a new value, it adds that value to total. When it gets to the end, all of the values have been added up. If we want an average, we don’t have to count the values ourselves. We can just use the len() function.\n\ntotal = 0\nmy_list = [4, 3, 4, 5]\nfor item in my_list:\n    total += item\navg = total / len(my_list)\nprint(avg)\n\n4.0\n\n\nSometimes you need to use a particular value in a list and you don’t want to iterate over the whole thing. For this, Python gives us indexing, letting us directly access any element of a list. The first (as it appears on screen, “leftmost”) element in numbered zero and each one after that goes up by one. The highest numbered one is therefore the length of the list minus one.\n\nprint(ingredients)\nprint()\nprint(\"Of all the biscuit ingredients,\", ingredients[0] , \"is the most important one.\")\nprint(\"The second most important one is\", ingredients[2])\n\n['flour', 'lard', 'baking powder', 'milk']\n\nOf all the biscuit ingredients, flour is the most important one.\nThe second most important one is baking powder\n\n\nLike the majority of programming languages, Python uses square brackets to indicate the index into the list. Unlike the vast majority of languages, Python allows indexes to be negative! A negative number for an index means “count backwards from the end”. my_list[-1] refers to the item at the end of the list. my_list[-3] refers to the third to last item.\n\nprint(ingredients[-1])\nprint(ingredients[-3])\n\nmilk\nlard\n\n\nWe’ve seen how to iterate over lists and also how to access individual list elements by using indexing. Python has a special indexing scheme, though, that lets us deal with small lists made from our original list. This is called List Slicing and can save you a lot of work sometimes. The overall syntax for this looks like list_name[start:end]\nAn example is definitely called for here:\n\nmy_list = [2, 4, 6, 8, 10, 12]\nprint(my_list[1:3])\n\n[4, 6]\n\n\nRemember that list indexes count from zero, and remember also that ranges in Python include the starting index (here, it’s the 1) and will continue to the last value that is smaller than the one on the right side of the colon.\nBoth the starting and the ending indexes are optional! If one of the two is missing, it will be interpreted as 0 or the list’s length, respectively.\n\nprint(my_list)\nprint()\nprint(my_list[:3])\nprint(my_list[1:])\nprint(my_list[:])\n\n[2, 4, 6, 8, 10, 12]\n\n[2, 4, 6]\n[4, 6, 8, 10, 12]\n[2, 4, 6, 8, 10, 12]\n\n\nAnd finally, the in operator is used to test list membership.\n\nlucky_numbers = [2, 7, 17, 9]\nplayer_number = int(input('Enter your favorite number'))\nif player_number in lucky_numbers:\n    print(\"Your favorite number is lucky!\")\nelse:\n    print(\"Sorry! Better luck next time!\")\n\nSorry! Better luck next time!\n\n\n\nThere’s Method to the Madness\n\nThere are two kinds of functions available for working with lists. Built-in functions are the ones that are part of Python itself. Methods, as you’ll recall from the unit on files, are special functions that are situated inside of objects and only usable with that kind of object. Python lists are objects. They’re iterable objects, in fact.\nLet’s take a look at a few of the methods available for working with lists. First up is append().\n\nprint(lucky_numbers)\nlucky_numbers.append(106)\n\nlucky_numbers\n\n[2, 7, 17, 9]\n\n\n[2, 7, 17, 9, 106]\n\n\nJust as the name implies, append() adds an element to the end of a list.\nBut what if we want to put a new element in a specific place? For that, there is insert().\n\nprint(lucky_numbers)\nlucky_numbers.insert(2, 202)\nlucky_numbers\n\n[2, 7, 17, 9, 106]\n\n\n[2, 7, 202, 17, 9, 106]\n\n\nThe insert function takes two arguments. The first is the position in the list where the insertion should happen. In the example above, it was at position 2. Remember, list indexes start at zero! The second argument is the element to insert. And when we look at the resulting list, we see that 202 is in position 2 now (which is the third position!) and all the other elements have been shifted to the right.\nWe’ve been fetching elements from the list by location number, so far. How do we find something by searching for it? The index() method does that.\n\nwhere_found = lucky_numbers.index(202)\nprint(where_found)\n\n2\n\n\nWe passed the argument 202 to the index method. It searched the list and returned the index of the first occurence. That index is 2. Makes sense because we just inserted it there a minute ago!\nIf we can insert things into a list then surely we can remove them too, right? Indeed we can with the remove() method.\n\nprint(lucky_numbers)\nlucky_numbers.remove(7)\nprint(lucky_numbers)\n\n[2, 7, 202, 17, 9, 106]\n[2, 202, 17, 9, 106]\n\n\nWatch out! remove() looks up an item, like index() does, and then removes it. It doesn’t take a position number. In other words:\n\npeople = ['David', 'Bill', 'Richard']\npeople.remove('Bill')\nprint(people)\n\n['David', 'Richard']\n\n\nYou might find yourself needing to sort the items in a list, and for that the sort() method exists:\n\nprint(lucky_numbers)\nlucky_numbers.sort()\nprint(lucky_numbers)\n\n[2, 202, 17, 9, 106]\n[2, 9, 17, 106, 202]\n\n\nFinally, there are methods to find the greatest and smallest values in a list.\n\nprint(min(lucky_numbers))\nprint(max(lucky_numbers))\n\n2\n202\n\n\nEarlier we saw the use of len() to find out how many items are in a list. This is a built-in function and works on many types of variables, not just lists. There are two more built-in functions that are useful for working with lists: min() and max().\n\nsiblings = ['David', 'Bill', 'Shirley', 'Richard', 'Laverne']\nprint(min(siblings))\nprint(max(siblings))\n\nBill\nShirley\n\n\n\n\nLists and Functions\n\nFunctions have no problem accepting lists as arguments and they can also return lists as the function’s value. There is a subtle “gotcha” when passing lists as an argument, though.\nFirst, let’s look at a simple example:\n\noriginal_list = [1, 2, 3, 9]\n\ndef sum_of_list(list_to_sum):\n    sum = 0\n    for i in list_to_sum:\n        sum = sum + i\n    return sum\n\nthe_sum = sum_of_list(original_list)\nthe_sum\n\n15\n\n\nThat worked as expected - there’s no problem passing lists into functions. What about returning lists from functions?\n\ndef pet_factory(how_many_pairs):\n    pets = ['goldfish', 'catfish'] * how_many_pairs\n    return pets\n\nmany_fish = pet_factory(5)\nprint(many_fish)\n\n['goldfish', 'catfish', 'goldfish', 'catfish', 'goldfish', 'catfish', 'goldfish', 'catfish', 'goldfish', 'catfish']\n\n\nEarlier, when we talked about functions in section 5, we said that if a function changes the value of one of its arguments then the effects of that change stay inside the function and aren’t visible to anything when the function exits. That statement was mostly true. If you pass a list as an argument to a function and if that function changes the list then the change made there will be visible outside. Strings, floats, and integers asre protected, but lists are more exposed.\n\noriginal_list = [1, 2, 3, 9]\n\ndef doubler(numbers):\n    for i in range(len(numbers)):\n        numbers[i]=numbers[i]*2\n\nprint(original_list)\ndoubler(original_list)\nprint(original_list)\n\n[1, 2, 3, 9]\n[2, 4, 6, 18]\n\n\nChanging the value of an argument inside of a function usually isn’t a great idea, but in the case of lists it can be useful.\n\n\nNo Funny Glasses Required\n\nThe lists we have worked with up to this point have all been one dimensional. Lists get a lot more interesting as the number of dimensions goes up.\nUnlike most programming languages, Python does not have a multi-dimensional list or array construction, per se. What Python does have is a list that is versatile enough to contain anything - and that includes containing other lists! A two-dimensional list in Python is just a “list of lists”.\nTake a look:\n\nfirst_presidents = [['George', 'Washington'], ['John', 'Adams'], ['Thomas', 'Jefferson']]\n\nAbove, on that very long line, we’ve created a list with square brackets. Inside that list, we’ve put three more lists inside square brackets of their own. So we’ve made a list of lists.\nThat long line is hard to read, isn’t it? Python won’t let us just split a long line of code across multiple lines… unless we explicitly tell it what we’re doing. That is done by ending each line with a backslash and immediately pressing enter. It looks like this:\n\nfirst_presidents = [['George', 'Washington'],\\\n                    ['John', 'Adams'],\\\n                    ['Thomas', 'Jefferson']]\n\nJupyter even goes to the trouble to line up the columns for us.\nAnyway, let’s see what we’ve created.\n\nprint(first_presidents)\n\n[['George', 'Washington'], ['John', 'Adams'], ['Thomas', 'Jefferson']]\n\n\n\nprint(first_presidents[0])\n\n['George', 'Washington']\n\n\n\nprint(first_presidents[2])\n\n['Thomas', 'Jefferson']\n\n\nWe can index into the outer array, the one that contains the smaller lists, just like we normally would. We can also index into the inner array two different ways. The long way…\n\npresident_number_one = first_presidents[0]\nfirst_name = president_number_one[0]\nfirst_name\n\n'George'\n\n\n… or we can take the shortcut:\n\nfirst_name = first_presidents[0][0]\nfirst_name\n\n'George'\n\n\nThe first zero got us to the “George”, “Washington” element, and the second zero indexed into that and gave us ‘George’. Let’s try some other combinations:\n\nnext_first_name = first_presidents[1][0]\nnext_first_name\n\n'John'\n\n\n\nanother_name = first_presidents[1][1]\nanother_name\n\n'Adams'\n\n\nIt’s easy to see how we’re indexing into this two-dimensional list. In fact, it works roughly the same way as a 2-D array in most programming languages.\nIt’s so similar, in fact, that you’re probably feeling the urge to do some Linear Algebra right now.\nDon’t. Not yet.\nPython’s multidimensional list support is exactly that: support for lists. It can be pressed into service for arrays (in the linear algebraic sense of the term) but performance is pretty bad. In Programming Elements 101 we’ll see a software library called “numpy”. It is superior for arrays where you want to do some math.\nNow let’s look at how to traverse multi-dimensional array. We’ll create a 2-D list that look like this:\n        Column 0  Column 1  Column 2  Column3\nRow 0.     A         B         C         D\nRow 1.     E         F         G         H\nRow 2.     I         J         K         L\nRow 3.     M         N         O         P\n\nletter_table = [['A', 'B', 'C', 'D'],\\\n['E', 'F', 'G', 'H'],\\\n['I', 'J', 'K', 'L'],\\\n['M', 'N', 'O', 'P']]\n\nWe can get a whole row:\n\nprint(letter_table[1])\n\n['E', 'F', 'G', 'H']\n\n\nor we can get a specific cell (the order is row, then column):\n\nprint(letter_table[2][1])\n\nJ\n\n\nWe can access the table by column, but it’s not as easy. We’ll have to write a loop that steps down a column and reads the values:\n\nfor i in range(len(letter_table)):\n    print(letter_table[i][3])\n\nD\nH\nL\nP\n\n\nWhat if we want to access all of the cells in the array? For that, nested loops work.\n\nfor row in range(len(letter_table)):\n    for col in range(len(letter_table[row])):\n        print(letter_table[row][col])\n\nA\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\n\n\n“But wait!”, I hear you say. “I need to store higher-dimensionality data!” No problem. Python will allow arbitrarily deep nesting. We can have lists of lists of lists (3 dimensions) or lists of lists of lists of lists for four dimensions. Accessing the cells is just a matter of adding more array indexes to the end of the name.\n\nfirst_vice_presidents = [[\"John\", \"Adams\"],\\\n                         [\"Thomas\", \"Jefferson\"],\\\n                         [\"Aaron\", \"Burr\"]]\n\nearly_us_leaders = [first_presidents, first_vice_presidents]\nprint(early_us_leaders[1][0][1])\nprint(early_us_leaders[1][2][0])\n\nAdams\nAaron\n\n\nIt’s easy to get confused with deeply nested lists. Three dimensions isn’t bad, four is managable, but as the structures get deeper and deeper I have to resort to drawing pictures and frequent testing every step of the way.\ntl;dr: If you’re a string theorist working in 21 dimensions or whatever, Python lists probably aren’t the way to go. You should use numpy.\n\n\nTuples\n\nA “double”, mathematically speaking, is two of something. A “triple” is three of them. If you don’t know how many, or you don’t want to specify, then it’s generically called a “tuple” (pronounced “Too pull”, according the The American Heritage Dictionary and, more importantly, everyone who has ever taught the database class).\nPython gracious provides us with tuples. Their syntax is just like a list, only using parentheses instead of square brackets. For instance:\n\nmy_tuple = (2, 8, 256)\nprint(my_tuple[1])\n\n8\n\n\nTuples have some restrictions when compared to lists. * You can’t sort them. * You can’t insert or delete from them * You can’t change the values in them\nWhy would we want tuples if they’re so similar to lists, only somewhat disabled? In a word, “speed”. They’re very fast compared to lists. That’s why some Python functions require them. The most likely time you’ll see tuples is when you’re accessing data from a database. The second most common use is when you need to return multiple values from a function.\nSince tuples have the speed advantage but lists are more versatile, it’s not unusual to see programmers use the list() and tuple() functions to convert between the two types:\n\nmy_tuple = (2, 8, 256)\nlist_version = list(my_tuple)\nlist_version\n\n[2, 8, 256]\n\n\n\nmy_list=[2, 4, 6, 8]\ntuple_version = tuple(my_list)\ntuple_version\n\n(2, 4, 6, 8)\n\n\nReturning multiple values from a function feels like cheating the first time you do it. After all, sin(x) returns exactly one number, right?\nWhat if you wrote a function that returns a complex number, like 1.105+7.3i ? That’s one number (albeit one on the complex plane) but it’s written like two pieces of data being returned.\nWhat if you got really fancy and wrote a function that returned a column vector? That would be like returning a lot of numbers all at once, wouldn’t it?\nSo returning multiple values at once isn’t that bad, is it? Especially if the values all have related meaning and “belong” together.\n\ndef get_extremes(number_list):\n    min_val = min(number_list)\n    max_val = max(number_list)\n    return (min_val, max_val)\n\nnumbers = [5, 3, 2, 7, 2, 5]\nlow, high = get_extremes(numbers)\nprint(low)\nprint(high)\n\n2\n7\n\n\nA couple of things to note. First, notice how the function creates a tuple and returns it. The parentheses indicate a tuple is being constructed and the min_val and max_val variables are put into the tuple as the first and second elements.\nSecond, look at how that tuple is returned to the caller, taken apart, and stored in a pair of variables. You’ll see the syntax first_variable, second_variable, third_variable = func() when a tuple is returned from a function. The first element of the tuple is placed in first_variable and so on.\n\n\nComing Up Next\n\nWe’ve made it to the end of this section. Take a moment, breathe, and relax… this is the longest module in the “Python and Jupyter” series. Next up we have lots of information on strings. We’ve been using strings a lot already without really looking at what they are and what they can do. It’s time to remedy that.\n(pssst. Want a hint? Strings are just tuples of letters!)"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-10Dictionaries.out.html",
    "href": "preliminaries/PRE100/PE100-10Dictionaries.out.html",
    "title": "PE100-10: Dictionaries",
    "section": "",
    "text": "Dictionaries are, conceptually, a special type of list. A list has an order to it. Elements are placed into a list in a particular order. Removing and inserting items changes the order in a well understood way. Because of this, yoiu can always access a list by looking into it at a specific integer index. None of this is possible with a dictionary. Instead, dictionaries have a better trick: all access is by searching.\nPython’s dictionaries store each of their elements as a pair of things, a key and a value. The key is the thing that can be searched for, and the value is the information that will be retured when that element is read.\nAn example will help:\n\nfavorite_food = { \"Alice\" : \"Apple Pie\", \\\n                 \"Bob\" : \"Ice Cream\",\\\n                 \"Charlie\" : \"Pizza\" }\nprint(favorite_food[\"Bob\"])\n                 \n\nIce Cream\n\n\nLet’s take that apart and see how it works.\n\nWe have the creation of the dictionary itself. We create a dictionary literal much like we do a list, only here we use curly brackets instead of square brackets.\nWe have key:value pairs. The keys we’re using are all strings (people’s names, in fact) but they could just as well be numbers. The values are also strings, but they can be anything we want. These keys and values are separated by colons (:).\nBetween each of the key:value pairs there is a comma.\nWe see how to look up information in a dictionary. It looks like indexing into a list to extract a particular element, except in this case we don’t give a positional index number but rather we give it a key to look up.\n\nWhen you think about it, looking for Bob’s favorite food by using favorite_food[\"Bob\"] is a pretty powerful tool. Rather than having to specify where to get something from, we can just specify what to get. This is why you’ll occasionally see dictionaries refered to as “Content Addressable Memory”. It’s nice to just get the data we want without having to step through every element of a list looking for it. It’s also faster: Python’s dictionaries use clever indexing so they can straight to what you’re looking for.\nDictionaries get their name, by the way, from real-world physical dictionaries. Suppose you have Webster’s 9th New Collegiate Dictionary in front of you. There are a lot of keys in there - each one of those words in alphabetical order is a key. There’s not really any way to look up something by page number alone - there’s no algorithm to tell me what page the definition for brisance is on. There’s no way to look up a word by knowing which word number it is. If brisance is the 8000th word in the dictionary, that knowledge does me no good. On the other hand, there is an algorithm for finding that definition by looking up the key word. I go to the “B”s, look for the “Br” part, and so forth until I find brisance. I can only look up things by key, not by position.\nOne of the great things about Python is its flexibility with data types. Lists can contain any data type. You can have lists of tuples of lists of strings if you want to. Dictionaries are similarly versatile. You can have dictionaries that contain, say, lists:\n\nfamily_info = { 'ages' : [6,8,36,38],\\\n               'names' : ['Jane', 'John', 'Alice', 'Bob'] }\n\nprint(family_info[\"names\"])\n\n['Jane', 'John', 'Alice', 'Bob']\n\n\nYou can even have dictionaries of dictionaries. They’re quite useful, in fact.\n\nfast_food = { \"McAwful\" : { \"address\" : \"1012 Western Blvd\",\\\n                            \"sanitation\" : 92} ,\\\n            \"Davids\" : { \"address\" : \"201 S Fayetteville St\",\\\n                         \"sanitation\" : 99.5 } }\n\nprint (fast_food[\"Davids\"][\"sanitation\"])\n\n99.5\n\n\nDictionaries give us the beginnings of a database. It’s not as powerful as a “real” database, but it’s good enough for a lot of things. Of course, a dictionary is like any iother variable: it only lasts as long as your program is running. You would have to combine a dictionary with some file access to have any permanent storage.\nWhat happens if we try to look up a key:value pair, and the key isn’t in the dictionary? Let’s see!\n\nprint(fast_food[\"Ruth's Chris\"])\n\nYeah, we expected that by now, didn’t we? It threw a “KeyError” exception. What should we do about this? We could always wrap the access up in a try/except structure to catch the KeyError, but this is such a common problem that Python gives us a friendlier way to do it: the in operator.\nRemember using in to see if something was in a string? This is philosophically similar. Let’s try it:\n\nif \"Ruth's Chris\" in fast_food:\n    print(\"Surprised to see such an expensive place here!\")\nelse:\n    print(\"that's a relief, actually.\")\n\nthat's a relief, actually.\n\n\nAdding to a dictionary is even easier than adding to a list. All you do is just act like the key was already there and assign it a value:\n\nprint(favorite_food)\nprint()\nfavorite_food[\"Dan\"] = 'Fish'\nprint(\"Now we have:\")\nprint(favorite_food)\n\n{'Alice': 'Apple Pie', 'Bob': 'Ice Cream', 'Charlie': 'Pizza', 'Dan': 'Fish'}\n\nNow we have:\n{'Alice': 'Apple Pie', 'Bob': 'Ice Cream', 'Charlie': 'Pizza', 'Dan': 'Fish'}\n\n\nWhat happens if we try to overwrite some data?\n\nfavorite_food[\"Charlie\"] = \"Soup\"\nprint(favorite_food)\n\n{'Alice': 'Apple Pie', 'Bob': 'Ice Cream', 'Charlie': 'Soup', 'Dan': 'Fish'}\n\n\nWe can change what is stored in the “value” part of the key:value pair any time we want. We can’t change the key, though. At least, we can’t change it directly. We can always delete the existing key:value pair and replace it with a new one. Let’s say Charlie really wants to be known as Chuck. He has his reasons. So let’s fix the favorite_food dictionary:\n\nmunchie = favorite_food[\"Charlie\"]\ndel favorite_food[\"Charlie\"]\nfavorite_food[\"Chuck\"]=munchie\nprint(favorite_food)\n\nWhat we did to accomplish that was 1. Look up Charlie’s favorite food and save that value. 2. use the built-in del operator to remove Charlie as a key and whatever value was associated with him. 3. Insert a new key:value pair whose key is “Chuck” and whose value is whatever we looked up before.\nSince every other Python data type that holds more than one thing can work with the built-in len() function, it stands to reason that dictionaries can, too. And as you would imagine, len() returns the number of entries in the dictionary.\n\nlen(favorite_food)\n\n4\n\n\n\nLooping and Iteration\n\nA dictionary is another type of iterable. This means we can write loops that traverse the entire dictionary, start to finish, and do something useful.\n\nfor key in favorite_food:\n    print(key)\n\nAlice\nBob\nDan\nChuck\n\n\nNotice that a traversal of a dictionary retrieves the keys. If you want to retrieve the values, just use the keys to look up the values.\nfor key in favorite_food: print(favorite_food[key])"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-07Exceptions.out.html",
    "href": "preliminaries/PRE100/PE100-07Exceptions.out.html",
    "title": "PE100-06: Exceptions",
    "section": "",
    "text": "Most of the time, the code we write does exactly what we expect. Our numbers are added up, files are written and read, and users type their input in neat little boxes. Sometimes, though, something goes wrong. Maybe the disk storage space filled up, or we try to write to a file in a directory we don’t have access to (or maybe the directory doesn’t even exist). When things like this happen, the Python interpreter stops the normal flow of execution.\nTake a look at an exception:\n\nfunny_number = 1/0\n\nWhen you run the above, Python will notice the error, stop the code from running, and point out that a “ZeroDivisionError” has occurred. Since this kind of thing wasn’t supposed to happen (division by zero is considered a Bad Thing(tm) by most people) we can say the situation we’re faced with is an exception. And indeed, Python’s error handling mechanisms are based on what are called “exceptions”.\nWhen Python saw the “division by zero” error, it stopped running the rest of the code. It created one of these Exceptions, and then it threw it. Nothing in our one-line example tried to do anything about that exception, so Python just let the program crash and it printed the helpful error messages for us.\nMost of the time, we want our code to be able to handle exceptions when they arrise. We want something that can catch these exceptions when they’re thrown. For that, we need to use Python’s try statement.\n\nTry, try again\n\ntry is how we safely wrap up a bit of code so that if something in there fails and an exception is thrown, we have a way to catch it. For example:\n\ntry:\n    denominator = int(input('Please enter the denominator'))\n    funny_number = 1000/denominator\n    print('the result was', funny_number)\nexcept ZeroDivisionError:\n    print('Looks like someone tried to divide by zero.')\nprint(\"Either we were able to do the division or else we successfully handled an exception.\")\n\n    \n\nLooks like someone tried to divide by zero.\nEither we were able to do the division or else we successfully handled an exception.\n\n\nTry running the code above a few times. In the input area, try some different numbers each time. Maybe 4, 0, and -2. Notice that division by non-zero numbers works as expected. Notice also that division by zero now lets us print out an error message instead of crashing. Once we’re done handling the exception, the program resumes with the first line after the try/except structure.\nIn fact, there might be several except clauses if there are several kinds of exceptions that might be thrown. For example, let’s figure out how to share a pizza.\n\ntry:\n    people = int(input('How many people:'))\n    slices = 8/people\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nexcept ValueError:\n    print(\"The number of people must be a valid integer.\")\nexcept ZeroDivisionError:\n    print(\"Seriously? There are zero people sharing a pizza?\")\n\nprint(\"Whatever happened up there, this is the first line of code after\")\nprint(\"the try/except structure.\")\n\nSeriously? There are zero people sharing a pizza?\nWhatever happened up there, this is the first line of code after\nthe try/except structure.\n\n\nAs you try different numbers of people, you can see that division by zero is, of course, handled. You can also enter things that aren’t integers. In response to the prompt, you could enter “Fred”. That can’t be converted to an integer, so the int() function throws an error. The except ValueError clause catches that exception and prints out a message.\nNotice that after either exception handler executes its code, the flow of control goes down to the next line after the try/except structure. In this case, that line is one that prints out a message saying it’s the first line of code after the try and all of the excepts.\nSometimes it’s hard to predict what exception might be thrown in a section of code. In that case, we can use just except: without any exception type. This serves as a “catch-all” handler.\n\ntry:\n    my_file = open('/tmp/ThisFileIsUnlikelyToExist', 'r')\n    people = int(input('How many people:'))\n    slices = 8/people\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nexcept ValueError:\n    print(\"The number of people must be a valid integer.\")\nexcept ZeroDivisionError:\n    print(\"Seriously? There are zero people sharing a pizza?\")\nexcept:\n    print(\"The catch-all handler has been awoken from its slumber.\")\n    print(\"I don't know what went wrong, except I can tell you it\")\n    print(\"wasn't a ValueError or a ZeroDivisionError, because\")\n    print(\"those would have been caught by more specific handlers\")\n    print(\"further up the list.\")\n\nThe catch-all handler has been awoken from its slumber.\nI don't know what went wrong, except I can tell you it\nwasn't a ValueError or a ZeroDivisionError, because\nthose would have been caught by more specific handlers\nfurther up the list.\n\n\nIndeed, if we’re lazy (or in a hurry) then we can get by with just a plain except clause and let the user figure it out later:\n\ntry:\n    my_file = open('/tmp/ThisFileIsUnlikelyToExist', 'r')\n    people = int(input('How many people:'))\n    slices = 8/people\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nexcept:\n    print(\"There was some sort of problem. I have no idea what.\")\n\nThere was some sort of problem. I have no idea what.\n\n\nUsing just a plain catch-all exception handler doesn’t give you much to work with, but it is slightly better than nothing. Your code won’t crash outright but you won’t much information about what went wrong. If only there was a way to examine that exception, to peer in and divine its secret nature…\nYep. Here you go…\n\ntry:\n    my_file = open('/tmp/ThisFileIsUnlikelyToExist', 'r')\n    people = int(input('How many people:'))\n    slices = 8/people\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nexcept Exception as err:\n    print(\"Error:\", err)\n\nError: [Errno 2] No such file or directory: '/tmp/ThisFileIsUnlikelyToExist'\n\n\nWhat we’ve done is catch any kind of exception (except Exception) and assigned it to a variable named “err”. Then we can print out err. We could even convert err to a string and search for the interesting parts (like the filename of our missing file) and do some clever error handling based on what specifically went wrong.\nPython has a few more tricks when it comes to exception handling, and these can be handy for making your code more readable.\n\n\nFancy exception handling\n\nA try/except structure can have an else clause. This clause will only be executed if no exception was thrown.\n\ntry:\n    people = int(input('How many people:'))\n    slices = 8/people\nexcept Exception as err:\n    print(\"Error:\", err)\nelse:\n    print('Each gets', format(slices, '.2f'), 'pieces.')\n\nError: division by zero\n\n\nIf the user enters something that can be converted to an integer and is non-zero, then the program continues, finishing up the try block and executing the else block. On the other hand, if an exception of any type is thrown then the “number of pieces” message will never be printed.\nThere is also a finally clause. This one will run after everything else has happened, no matter what.\n\ntry:\n    output_file = open(\"/tmp/output\", \"w\")\n    people = int(input('How many people:'))\n    slices = 8/people\nexcept Exception as err:\n    print(\"Error:\", err)\nelse:\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nfinally:\n    output_file.close()\n\nError: division by zero\n\n\nIn the try clause, a file opening was added. In the finally clause, the file will be closed whether an exception was thrown or not.\nHow useful are else and finally clauses? It’s true they’re not absolutely necessary. Most programming languages don’t have anything like that. You can always juggle your code around and get by with just try and except. On the other hand, these two clauses can make your code easier to read and understand. Your precise intention can be discerned.\nWe’ve seen how to write Python code that catches errors without crashing. This technique works in both regular Python programs and in Jupyter Notebooks. Next up, we’ll turn back to ways of storing information. This time we’ll look at lists."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "",
    "text": "Niklaus Wirth was one of the founding giants of Computer Science. He wrote an introductory textbook whose title neatly summed up the act and art of programming: Algorithms + Data Structures = Programs. Data Structures are how information is stored in a computer, and algorithms are the instructions the computer applies to transform that data.\nTo run the code in a cell, first click in the cell to select it. Then you can either: 1. Go to the “Run” menu and choose “Run Selected Cells”, or 1. Just press Shift + Enter.\nLet’s do this now: click just below where it says “print (403.616”), then Go to the “Run” menu and choose “Run Selected Cells”.\nprint (403.616)\n\n403.616\nWhen it ran, it printed “403.616” on a line by itself. That was the output from the print.\nClick in the next cell (where it says “103.5”) to select that cell. Then hold down the Shift key while you press Enter.\n103.5\nIn Python, and in Jupyter notebooks, if the last (or only!) line evaluates to some value then it will be printed out. That’s how “103.5” got printed - a literal number evaluates to that number when it’s run. A “literal number” means you look at it in your code and you literally see a number.\nTake a look at a string literal. Run each of the next two cells…\nprint (\"the quick brown fox\")\nprint ('jumped over the lazy dogs')\nAt this point, we can use Python and Jupyter Lab as a scientific calculator. We have some literals of different types (int, real, and string, so far) and we can print them out with the print() function. If we don’t explicitly print anything at the end of a cell, Python will show us the last value that was computed."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#operators",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#operators",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Operators",
    "text": "Operators\nLike any programming language, Python lets you “do math” and lots of other things. Let’s take a look at some of the basic “operators”. In all of the code-containing cells through this course, try to predict what will happen first, and then run the code.\n\n2+2\n\n\n2*8\n\n\n6-4\n\n2\n\n\n\n7*6\n\n\n16/3\n\nBesides the “classic” operators, there are some handy extras:\n\n16//3\n\nWhat happened there? The // operator does integer division - it returns the whole number part of the answer, just like when we learned division in elementary school.\n\n16%3\n\nThe % operator returns the remainder. This is also called “modulo”, and the above would be pronounced “sixteen mod 3”.\n\n2**8\n\n256\n\n\n\n4**2.718281828459045\n\nThe ** operator does exponentiation. The arguments can be integers or they can be real numbers. Naturally, operators can be combined into arbitrarily long expressions.\n\n3*4*5\n\n\n6+4*5\n\nNotice what happens when we use different operators. They are applied in the “My Dear Aunt Sally” order of precendence (multiplication, division, addition, subtraction).\nOrder of operations: * Exponentiation: ** * Multiplication, Division, Remainder: * / // % * Addition and Subtraction: + -\nWithin the same level, operators are applied left-to-right. 8-5+2 is evaluated as 3+2 and yields 5. The exception is exponentiation: 2 ** 3 ** 4 is treated as 2 ** 81 and yeilds an annoyingly large number\n\nprint (2**3**4)\n\n\nprint (2**81)"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#variables",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#variables",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Variables",
    "text": "Variables\nUnless we just use Jupyter as a big, expensive scientific calculator, we need a way to store data. Variables were invented for just that purpose, and virtually every language has them. Think of them as a place to store data of some kind, and that place has a name. They behave in Python just like you’d expect.\n\nanswer = 42\nprint(answer)\n\n42\n\n\nWe just created a variable named answer and gave it the value 42. Variables are long-lived - later we’ll talk about just how long when we start writing our own functions, but until then our variables last as long as Python (or in our case, Jupyter) is running. Take a look - answer is still there.\n\nprint(answer)\n\nThe value stored in a variable can change. It can even change type:\n\nweight = 60\nweight = 70\nprint(weight)\nweight = \"not very much.\"\nprint(weight)\n\nWe can declare many variables, and we can “do things” with them just like we can when we type in numbers or strings.\n\nvolts = 120\namps = 4\nwatts = volts * amps\nwatts\n\nIn the last line, we just put watts because Jupyter automatically prints what the last line evaluates to.\nWe can use variables to change the order of operations. Let’s see the average price of two people’s meals:\n\ntotal = 22.41 + 19.45\naverage = total / 2\naverage\n\nThat’s the right answer. If we hadn’t done that, we would have gotten\n\n22.41 + 19.45 / 2\n\nwhich is utterly wrong. Beware of the order of operations… it is a frequent source of bugs in scientific programming.\n\nVariable Naming Rules\nFor the most part, you can pick whatever name makes sense for a variable, but there are some rules. When choosing a name: 1. No keywords (False won’t work.) 1. No spaces (sample thickness is invalid) 1. The first character must be one of * a-z, or A-Z, or _. (the underscore character) * As a result, no numbers (3rd_sample_holder is invalid) 1. After the first character, you can then have numbers (sample_holder_3 is perfectly valid) 1. No other symbols are allowed (exploded&destroyed_spectrometers is invalid, and probably suggests it’s time to review lab safety procedures).\nNote: Uppercase vs. Lowercase matters! Bevatron is not the same variable as bevatron"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#types",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#types",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Types",
    "text": "Types\nWe’ve hinted that variables have a “type”, and that the type can change if it needs to. The way it works is that variables keep track of what type they are (integer, real number, or string) and what their “value” is. We can even interrogate a variable as see what type it is:\n\nreading=7.2\nprint(\"reading:\")\nprint(type(reading))\nreading=\"rainbow\" # changes type of reading to string\nprint(type(reading))\n\nreading:\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\n\nmy_number = 42\nmy_string = \"was that really the right answer?\"\n\nfirst_type = type(my_number)\nsecond_type = type(my_string)\nprint(first_type, second_type)\n\nThe type of a variable matters. Let’s create a variable with an integer in it and another with a string. Then let’s do some math:\n\nfirst_thing = 6\nsecond_thing = \"7\"\n\nprint (first_thing + second_thing)\n\nHow do we handle situations like that, where second_thing held a string representing a seven, but because it was a string variable it couldn’t be used as an integer? Python provides a few functions to convert values from one type to another. The str() function takes a variable and converts it to a string. The float() and int() functions convert their arguments to floating-point and to integer numbers, respectively.\n\nprint(first_thing + int(second_thing))\nprint(first_thing + float(second_thing))\n\n13\n13.0\n\n\nBeing able to convert values from one type to another is often called type coercion. These conversions are extremely important for situation where you need to get input from a user, even more so if you need to do it repetitively."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#continuation-character",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#continuation-character",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Continuation Character",
    "text": "Continuation Character\nSometimes the expressions we need to evaluate can be very long. It would be nice if we could split up a long expression and spread it out over a few lines. As a small example, we’ll take a look at 4+2+3. Many programming languages will let us split an expression anywhere we want, such as:\n\n4+2\n+3\n\n…but that result isn’t right in Python. The last line, +3, was evaluated and printed as the result of running that cell. In Python,it turns out, if we need to continue an expression on the next line we must end the current line with a backslash \\ and press enter. It has to be a backslash, by the way, and cannot be the forward slash like we use for division.\n\n4+2\\\n+3\n\n9\n\n\nTime for an exercise! Try to predict what will be printed when you run the next cell. Then, run the next cell and see how you did. If you miss one, make sure you figure out what happened before you go. I know, we’re professionals, I shouldn’t have to say that…\n\nprint(1 + 3 + 5 * 4 / 2)\nprint(7 % 2 * 10)\nbig_num = 1 + 2 + 3 + 4 \\\n     + 5 + 6\nprint(big_num)\n\nNow write an expression to average three numbers (12, 14, and 66), divide the result by three, and square it. You can use the code cell right below here:"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#the-string-type",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#the-string-type",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "The String Type",
    "text": "The String Type\nAt the beginning of this notebook, we casually mentioned “strings” without saying what they are. They’re just “sequences of characters”. And these can be any kind of characters - the English alphabet, the Hungarian alphabet, hiragana… it doesn’t matter.\n\nprint(\"I'll see you mañana, assuming I don't get irradiated to death.\")\n\nSome, probably most, languages contain strings inside “double quotes”, \", which is shift+apostrophe on US English keyboards. Other languages (SQL and Pascal are the only two I can think of) use single quotes: '. Python lets you use either one. You do have to be consistent in each string, but it can vary from one string to the next:\n\nprint(\"double quotes work\")\nprint('single quotes also work')\nprint('but do not try to mix the two in one string!\"\n\nBecause we can use either type of quotation mark, we can exploit that to let us put quotation marks into strings:\n\nprint(\"Don't put explosive mixtures in the spectrometer, please.\")\nprint('Of course he was warned... \"Do not turn the spectrometer into a bomb, please\" but I am sure he ignored that.')\n\nDon't put explosive mixtures in the spectrometer, please.\nOf course he was warned... \"Do not turn the spectrometer into a bomb, please\" but I am sure he ignored that.\n\n\nThat lets us embed whichever kind of quotation mark we need into a string.\nBut what if we need to embed both kinds of quotes into one string? We’re in luck: we can use the backslash character again to “quote” our quotation mark. In fact, we can quote any character with it if we need to.\n\nprint(\"We told him \\\"Hexanitrohexaazaisowurtzitane and spectrometers don't mix, buddy\\\", but we're pretty sure he ignored us.\")\n\nWe told him \"Hexanitrohexaazaisowurtzitane and spectrometers don't mix, buddy\", but we're pretty sure he ignored us.\n\n\nThat sentence contains three things, inside the string itself: 1. Double Quotes to surround a direct quotation 2. A single quote, also called an apostrophe depending on how it’s used, to make a contraction, and 3. A totally awesome/terrifying molecule you have to google to believe.\nOK, I’ll save you the trouble. Prepare to lose most of a day’s productivity. You’re welcome.\n(Derek has written gobs of articles on fun substances. Here are some more. )\nThere is one last kind of string literal. Sometimes you need a string that is several lines long. The “triple quote” is a way to do it. You have to use three double-quotes in a row:\n\ngigantic = \"\"\"This is the first line,\nThis is the second,\nand this is the third and final line of my string.\"\"\"\nprint(gigantic)\n\nTriple quotes are also an easier way to embed mixed kinds of quotation marks into strings:\n\nmovie_opinion = \"\"\"I know people who say \"The Avengers\" isn’t a good movie, but I don’t agree.\"\"\"\nprint(movie_opinion)\n\nI know people who say \"The Avengers\" isn’t a good movie, but I don’t agree."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#coming-up-next",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.html#coming-up-next",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Coming Up Next",
    "text": "Coming Up Next\nWe just looked at enough of Python and Jupyter notebooks to use it as a basic calculator, but so far we can’t do any real, general-purpose programming with it. The “flow of control” sob far as been a straight line from top to bottom and we can’t change what we’re doing in response to different inputs. That’s about to change. In the next section we’ll look at the if statement and how to use it."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-01Introduction.out.html",
    "href": "preliminaries/PRE100/PE100-01Introduction.out.html",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks",
    "section": "",
    "text": "(PE100)\nWelcome to the Programming Essentials - Python Programming and Jupyter Notebooks component of the X-CITE training materials. The intent behind this unit is to show new CHESS users how to write programs in Python for experimental data analysis.\nPrerequisites? None.\nThe training materials before you are designed both for scientists who may not have any programming experience whatsoever and for those who have at least some basic programming capability but in a language other than Python.\nPython’s adoption has exploded in the last decade. Much of its success can be attributed to productivity. Many programming languages force the programmer to deal with very small details to do even the simplest things. Python’s attitude is to just take care of all the minutae so we don’t have to. On top of that, Python’s popularity has resulted in hundreds of thousands of packages of useful code for specific tasks. If there is something you need to write a program for, it’s almost definite that someone else has had the same problem. There’s a good chance at least one of those people neatly wrapped up some of their code and made it available in one of the repositories on the internet. There’s no reason for you to reinvent the proverbial wheel again - take advantage of their work (don’t forget to cite it!) and get back to doing actual science that much sooner.\nYou’re currently looking at PE100-01 Introduction. If you are new to Python and especially if you’re new to programming, you should work through each of the modules in order. More experienced programmers might benefit from skipping directly to topics that interest them. Select one of the following:\n\nPE100-02 Types, Variables, and Operators - the heart of any programming language.\nPE100-03 Decision Structures - conditional statements (“if” statements”) change the program flow.\nPE100-04 Repetition - “while” and “for” loops let us do things over and over.\nPE100-05 Functions - Python comes with a lot of functions, but we can write even more.\nPE100-06 Files - Reading input from and storing your results to disk.\nPE100-07 Exceptions - Dealing with unexpected contingencies.\nPE100-08 Lists - Another kind of variable, and the key to structuring data storage.\nPE100-09 Strings - More details on working with text.\nPE100-10 Dictionaries - Like a simple database, look up information quickly."
  },
  {
    "objectID": "preliminaries/PRE101/index.html",
    "href": "preliminaries/PRE101/index.html",
    "title": "CITEAM",
    "section": "",
    "text": "This is where the intro worked example will be."
  },
  {
    "objectID": "preliminaries/PRE101/index.html#placeholder",
    "href": "preliminaries/PRE101/index.html#placeholder",
    "title": "CITEAM",
    "section": "",
    "text": "This is where the intro worked example will be."
  },
  {
    "objectID": "preliminaries/PRE100/index.html",
    "href": "preliminaries/PRE100/index.html",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "",
    "text": "Note\n\n\n\nThe content in this page is written in the form of Jupyter notebooks. You can read the HTML version of the notebooks here. However, you will likely want to open and run the notebooks in a JupyterHub instance, such as CLASSE JupyterHub. See CLASSE Wiki for details."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#operators",
    "href": "preliminaries/PRE100/index.html#operators",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Operators",
    "text": "Operators\nLike any programming language, Python lets you “do math” and lots of other things. Let’s take a look at some of the basic “operators”. In all of the code-containing cells through this course, try to predict what will happen first, and then run the code.\n\n\n2\n\n\nBesides the “classic” operators, there are some handy extras:\nWhat happened there? The // operator does integer division - it returns the whole number part of the answer, just like when we learned division in elementary school.\nThe % operator returns the remainder. This is also called “modulo”, and the above would be pronounced “sixteen mod 3”.\n\n\n256\n\n\nThe ** operator does exponentiation. The arguments can be integers or they can be real numbers. Naturally, operators can be combined into arbitrarily long expressions.\nNotice what happens when we use different operators. They are applied in the “My Dear Aunt Sally” order of precendence (multiplication, division, addition, subtraction).\nOrder of operations: * Exponentiation: ** * Multiplication, Division, Remainder: * / // % * Addition and Subtraction: + -\nWithin the same level, operators are applied left-to-right. 8-5+2 is evaluated as 3+2 and yields 5. The exception is exponentiation: 2 ** 3 ** 4 is treated as 2 ** 81 and yeilds an annoyingly large number"
  },
  {
    "objectID": "preliminaries/PRE100/index.html#variables",
    "href": "preliminaries/PRE100/index.html#variables",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Variables",
    "text": "Variables\nUnless we just use Jupyter as a big, expensive scientific calculator, we need a way to store data. Variables were invented for just that purpose, and virtually every language has them. Think of them as a place to store data of some kind, and that place has a name. They behave in Python just like you’d expect.\n\n\n42\n\n\nWe just created a variable named answer and gave it the value 42. Variables are long-lived - later we’ll talk about just how long when we start writing our own functions, but until then our variables last as long as Python (or in our case, Jupyter) is running. Take a look - answer is still there.\nThe value stored in a variable can change. It can even change type:\nWe can declare many variables, and we can “do things” with them just like we can when we type in numbers or strings.\nIn the last line, we just put watts because Jupyter automatically prints what the last line evaluates to.\nWe can use variables to change the order of operations. Let’s see the average price of two people’s meals:\nThat’s the right answer. If we hadn’t done that, we would have gotten\nwhich is utterly wrong. Beware of the order of operations… it is a frequent source of bugs in scientific programming.\n\nVariable Naming Rules\nFor the most part, you can pick whatever name makes sense for a variable, but there are some rules. When choosing a name: 1. No keywords (False won’t work.) 1. No spaces (sample thickness is invalid) 1. The first character must be one of * a-z, or A-Z, or _. (the underscore character) * As a result, no numbers (3rd_sample_holder is invalid) 1. After the first character, you can then have numbers (sample_holder_3 is perfectly valid) 1. No other symbols are allowed (exploded&destroyed_spectrometers is invalid, and probably suggests it’s time to review lab safety procedures).\nNote: Uppercase vs. Lowercase matters! Bevatron is not the same variable as bevatron"
  },
  {
    "objectID": "preliminaries/PRE100/index.html#types",
    "href": "preliminaries/PRE100/index.html#types",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Types",
    "text": "Types\nWe’ve hinted that variables have a “type”, and that the type can change if it needs to. The way it works is that variables keep track of what type they are (integer, real number, or string) and what their “value” is. We can even interrogate a variable as see what type it is:\n\n\nreading:\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\nThe type of a variable matters. Let’s create a variable with an integer in it and another with a string. Then let’s do some math:\nHow do we handle situations like that, where second_thing held a string representing a seven, but because it was a string variable it couldn’t be used as an integer? Python provides a few functions to convert values from one type to another. The str() function takes a variable and converts it to a string. The float() and int() functions convert their arguments to floating-point and to integer numbers, respectively.\n\n\n13\n13.0\n\n\nBeing able to convert values from one type to another is often called type coercion. These conversions are extremely important for situation where you need to get input from a user, even more so if you need to do it repetitively."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#continuation-character",
    "href": "preliminaries/PRE100/index.html#continuation-character",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Continuation Character",
    "text": "Continuation Character\nSometimes the expressions we need to evaluate can be very long. It would be nice if we could split up a long expression and spread it out over a few lines. As a small example, we’ll take a look at 4+2+3. Many programming languages will let us split an expression anywhere we want, such as:\n…but that result isn’t right in Python. The last line, +3, was evaluated and printed as the result of running that cell. In Python,it turns out, if we need to continue an expression on the next line we must end the current line with a backslash \\ and press enter. It has to be a backslash, by the way, and cannot be the forward slash like we use for division.\n\n\n9\n\n\nTime for an exercise! Try to predict what will be printed when you run the next cell. Then, run the next cell and see how you did. If you miss one, make sure you figure out what happened before you go. I know, we’re professionals, I shouldn’t have to say that…\nNow write an expression to average three numbers (12, 14, and 66), divide the result by three, and square it. You can use the code cell right below here:"
  },
  {
    "objectID": "preliminaries/PRE100/index.html#the-string-type",
    "href": "preliminaries/PRE100/index.html#the-string-type",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "The String Type",
    "text": "The String Type\nAt the beginning of this notebook, we casually mentioned “strings” without saying what they are. They’re just “sequences of characters”. And these can be any kind of characters - the English alphabet, the Hungarian alphabet, hiragana… it doesn’t matter.\nSome, probably most, languages contain strings inside “double quotes”, \", which is shift+apostrophe on US English keyboards. Other languages (SQL and Pascal are the only two I can think of) use single quotes: '. Python lets you use either one. You do have to be consistent in each string, but it can vary from one string to the next:\nBecause we can use either type of quotation mark, we can exploit that to let us put quotation marks into strings:\n\n\nDon't put explosive mixtures in the spectrometer, please.\nOf course he was warned... \"Do not turn the spectrometer into a bomb, please\" but I am sure he ignored that.\n\n\nThat lets us embed whichever kind of quotation mark we need into a string.\nBut what if we need to embed both kinds of quotes into one string? We’re in luck: we can use the backslash character again to “quote” our quotation mark. In fact, we can quote any character with it if we need to.\n\n\nWe told him \"Hexanitrohexaazaisowurtzitane and spectrometers don't mix, buddy\", but we're pretty sure he ignored us.\n\n\nThat sentence contains three things, inside the string itself: 1. Double Quotes to surround a direct quotation 2. A single quote, also called an apostrophe depending on how it’s used, to make a contraction, and 3. A totally awesome/terrifying molecule you have to google to believe.\nOK, I’ll save you the trouble. Prepare to lose most of a day’s productivity. You’re welcome.\n(Derek has written gobs of articles on fun substances. Here are some more. )\nThere is one last kind of string literal. Sometimes you need a string that is several lines long. The “triple quote” is a way to do it. You have to use three double-quotes in a row:\nTriple quotes are also an easier way to embed mixed kinds of quotation marks into strings:\n\n\nI know people who say \"The Avengers\" isn’t a good movie, but I don’t agree."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#coming-up-next",
    "href": "preliminaries/PRE100/index.html#coming-up-next",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Coming Up Next",
    "text": "Coming Up Next\nWe just looked at enough of Python and Jupyter notebooks to use it as a basic calculator, but so far we can’t do any real, general-purpose programming with it. The “flow of control” sob far as been a straight line from top to bottom and we can’t change what we’re doing in response to different inputs. That’s about to change. In the next section we’ll look at the if statement and how to use it."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#the-simplest-if-statement",
    "href": "preliminaries/PRE100/index.html#the-simplest-if-statement",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "The Simplest “if” Statement",
    "text": "The Simplest “if” Statement\nIn almost any real Jupyter notebook or standalone program we write, there will have to be places where different code paths are taken depending on what has happened leading up to there. Suppose we’re looking at absorption at one specific wavelength and we know that some of our instruments are a little bit too sensitive to changes in humidity. Maybe the first spectrometer has some insulation that is just a little too porous and reads a bit high, but the second one is even worse. We have calibration constants we can apply, but we have to apply the right constant for each individual instrument.\n\n\n7.539441569999999\n\n\nHere we have the first Decision Structure (also called control flow statement) that we’ll look at. Taking the above code apart, we see several important things.\n\nThis is an “if statement”.\nTesting to see if two things are equal is done with two equals signs, not one (==). There’s a historical reason for this, and it’s a good reason, but it always trips up newcomers. You have been warned. You’re welcome.\nThe last character on the if line is : (a colon ).\nThe “body” of the if statement, the part that is run if and only if the tested condition is met, is indented.\n\nIn the case of the above if statement, what the code does is check to see if we’re using spectrometer number 1 and if we are then we add 7.7% to the reading and save it in a variable called “useful_result”."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#else-the-catch-all-specialist",
    "href": "preliminaries/PRE100/index.html#else-the-catch-all-specialist",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Else: the catch-all specialist",
    "text": "Else: the catch-all specialist\nIf that was all an if statement could do then it would be really useful. But that’s not all it can do. We need to do something reasonable when we get readings from the second instrument. Such as:\n\n\n8.3304879\n\n\nHere we have added an “else clause”. The above code is interpreted as “check to see if we’re using spectrometer number 1 and if we are then we add 7.7% to the reading and save it in a variable called useful_result. Otherwise, set useful_result to whatever is saved in”reading” plus 19%.\nSo far, so good. But there’s more! Suppose we need to handle several of these not-quite-top-quality spectrometers. How do you suppose we could deal with that? We could resort to putting if-else statements inside if-else statements in sort of a brute force fashion…\n\n\n6.4403771999999995\n\n\nThe above code looks a little intimidating, but all there is to it is just a series of if statements. The logic of it goes like this: “If the instrument number is 1, then adjust it 7.7% and we’re done. Otherwise, it must be some other instrument number, so run our else clause”. Then in the else clause, it does the same thing, except checking for the second instrument and adjusting by 19%. If there was nothing to do there (because the instrument number was 3) then we run the else clause of that second if statement. This else clause houses an if statement that checks to see if the instrument is number three. This time it is, so the body of the if statement is executed. We set useful_reading equal to 92% of reading."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#elif",
    "href": "preliminaries/PRE100/index.html#elif",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Elif",
    "text": "Elif\nThis is fine if we only have three instruments, but what do we do if we have 20 of them? We could, in principle, type in 60 lines of code, but that would be tedious, error prone, and would take a while to read and find any mistakes. Of course there’s a better way.\nThat better way is the “elif” keyword.\nLet’s see an example with 5 instruments…\n\n\n7.210422299999999\n\n\nThe final else clause is the one that runs if no other clauses ran. If no clause’s conditional statement is true so no clause runs, whether it’s the if clause or any of the elif clauses, then the else clause runs. It’s really easy to spot else clauses even from across the room - they’re the ones that don’t have a conditional test.\nNote that the if, elif, and else lines must end with a colon. True confession time: I forget the colons about half the time. Python catches it as an error, I fix it, and life goes on."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#slightly-more-complicated",
    "href": "preliminaries/PRE100/index.html#slightly-more-complicated",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Slightly More Complicated",
    "text": "Slightly More Complicated\nYou can run more than one line of code in response to the tested conditions, but they have to be indented the same amount:\n\n\n7.00041 True\n\n\nThere are four interesting things going on here. The first and most important thing to notice is that we’ve got more than one line of code running in response to an “if”, “elif”, or “else” clause. A collection of lines that should be run together as a whole is called a code block. Unlike many languages that mark the start and end of code blocks with special words or characters, Python just does it by using indentation. Everything that is indented the same amount is considered to be in the same code block. We’ll look at this in more detail in a few minutes.\nSecondly, we’ve added lines to set a variable named “trustworthy” to a value depending on whether we had to adjust the reading. Evidently, if we have to compensate for old, dry, cracking insulators then we don’t really trust the instrument.\nThe third interesting thing is the values True and False. These are “Boolean” values, and when we put them into the “trustworthy” variable then it takes on the Boolean type. There are only two values, True and False. The capitalization is important.\nThe fourth thing to notice is that we’re sending two values into the print statement and it’s printing both of them. In general, we can give the print statement any number of arguments, separated by commas, and it will print all of them separated by one space."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#conditional-aka-relational-operators",
    "href": "preliminaries/PRE100/index.html#conditional-aka-relational-operators",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Conditional (aka Relational) Operators",
    "text": "Conditional (aka Relational) Operators\nThe conditional test in each part of an if statement is an expression that results in a Boolean value. So far, the only conditional operator (or relational operator) we’ve seen is ==. There are others, though. For the sake of completeness, I’ll include == here:\n\n\n\noperator\ntested condition\n\n\n\n\n==\nequals\n\n\n!=\nnot equals\n\n\n&gt;\ngreater than\n\n\n&gt;=\ngreater than or equal\n\n\n&lt;\nless than\n\n\n&lt;=\nless than or equal\n\n\n\n“Relational” has at least two meanings in computing. Relational Operators have nothing to do with Releational Databases.\n\nTry This\nFor each of the following code cells, decide what the result is, run the cell, and see how you did:\n\n\nTrue\n\n\n\n\nTrue\n\n\n\n\nFalse\n\n\n\n\nFalse\n\n\n\n\nFalse\n\n\nRelational operators also work with strings.\n\n\nequals Alice.\nThe person is not Bob.\nAlice comes before Bob in alphabetical order.\nAlice comes before or in the same place as Alice in sorted order\nWorking left to right, the M, the a, and the r match on\nboth strings, but when we finally get to the y and the k, y comes\nafter k in alphabetical order.\n\n\nA couple words of caution: the comparisons are based on the ASCII codes for each character. The “A” in ASCII stands for “American”, and as you might expect that means it only works for English language text. If you need to handle other languages, even potentially, then there is a better way to do it and we’ll see that in the lesson on strings.\nAlso, Capital letters are always less than lowercase letters, and not in the way you might think. “A” is less than “Z”, as you might expect, but “Z” is greater than “a”. The numbers 0-9 are the lowest of all. Punctuation is sprinkled around and the only way to know for sure is to look up “ASCII Chart”."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#code-blocks",
    "href": "preliminaries/PRE100/index.html#code-blocks",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Code Blocks",
    "text": "Code Blocks\nLet’s go back to that part about running several lines of code but they have to be indented the same amount. Python always runs “blocks” of code. That block might be as short as one line:\n\n\n125.6636\n\n\nor it might be arbitrarily long:\n\n\n1511396.1762899999\n\n\nWhether it was the one line example or the eight line one, Python will set out to run all of those lines in one shot, and as long as there aren’t any errors it’ll do it. These are known as code blocks.\nThe decision structures (again, also called control flow statements) in Python all do basically the same thing: they evaluate an expression and depending on whether it turns out True or False, they execute a code block in some manner. This means that wherever we can have a single line of code running in a decision structure we can have as many lines as we want.\nTake a look at the following example. For the four possible combinations of potentially_hazardous and explody, decide what would be printed out. Then try out the combinations and make sure you know why each combination was handled the way it was.\n\n\nTotal Available Kaboom (TAK) to ruin your day is 1511396.1762899999\n\n\nDid you notice potentially_hazardous and explody? and is a boolean operator. We’ve seen the arithmetic operators already (+, -, *, /, etc.) and now here are the boolean operators. They’re named after Boolean algebra, the algebra of logic, and are used to make larger logical expressions from smaller ones. There are three boolean operators: and, or, and not.\nThe and operator evaluates to True if both of its arguments are True. The or operator evaluates to True if either or both of its arguments are true. The not operator takes only one argument and reverses it: not turns True into False and False into True.\n\n\nDoctor of Medical Dentistry (DMD)"
  },
  {
    "objectID": "preliminaries/PRE100/index.html#coming-up-next-loops",
    "href": "preliminaries/PRE100/index.html#coming-up-next-loops",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Coming Up Next: Loops",
    "text": "Coming Up Next: Loops\nAt this point, we’ve seen the most basic way to alter the flow of control in Python: the if statement. We can write Python code to solve non-trivial problems now, but there are still some things we need in order to use Python as a truly general-purpose language. In the next notebook we’re going to make our code do something over and over."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#while-loops",
    "href": "preliminaries/PRE100/index.html#while-loops",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "While Loops",
    "text": "While Loops\nThe syntax of a while loop looks a bit like an if statement. Take a look:\n\n\nLooking at instrument number 1\nand then maybe we'll look at the next one.\nLooking at instrument number 2\nand then maybe we'll look at the next one.\nDone with all that looping.\n...and ready to do something else now.\n\n\nHere’s what the above code does. First, it creates a variable named “instrument” and sets it to 1. Then it goes into the while loop. The first time through, it checks to see if instrument is less than or equal to 2. It is (because we set it to 1 just a moment ago) so the while loop will execute the code block. This block prints out two lines and then it adds 1 to instrument. That means instrument now equals 2.\nThe second time through the loop, instrument equals 2. That satisfies the conditional statement of the while loop (2 is less than or equal to 2) so the code block runs again. Two more lines are printed out and then instrument is incremented one more time.\nThe while loop runs for a third time now. This time, 3 is not less than or equal to 2, so the conditional statement is false. This means the while loop is done - it won’t run its code block again, and the flow of control will go on to the next line after the while loop. It will run the two print statements explaining that the looping is over and it can go on to other tasks.\nLet’s look at another example. Let’s print out all the powers of two that are less than 928.\n\n\n2 to the 0 equals 1\n2 to the 1 equals 2\n2 to the 2 equals 4\n2 to the 3 equals 8\n2 to the 4 equals 16\n2 to the 5 equals 32\n2 to the 6 equals 64\n2 to the 7 equals 128\n2 to the 8 equals 256\n2 to the 9 equals 512\n2 to the 10 is too big.\n\n\nDid you notice I sneaked something in there we haven’t talked about yet? See the “#” character on the line with the while statement? That indicates the rest of the line is a comment. Python will totally ignore it. It’s handy for leaving little notes to yourself, like “why did I choose 928 there when I could have put 944?” This is very, very important when writing full-fledged, standalone programs. If you don’t leave some notes for yourself, you’ll never remember what you were thinking when you go back to that code six months from now. Also, the next person who comes along and has to change something in your code will greatly appreciate the hints.\nLeaving comments in the code isn’t as big a deal in Jupyter notebooks… you can write rather substantial notes in a Markdown cell complete with boldface, italics, and whatever other fanciness you desire. On the other hand, it’s also nice to be able to leave your comments in the just the right place in the code so it flows effortlessly through your comprehension as you read it. Let experience and personal opinion be your guide here."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#reading-information-from-the-outside-world",
    "href": "preliminaries/PRE100/index.html#reading-information-from-the-outside-world",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Reading information from the outside world",
    "text": "Reading information from the outside world\nNotice that in both of those cases, we actually did know how many times the loop would run. We know that 2 to the 9th is 512 and so we know the while loop will only run that far. In fact, in every example we’ve had so far we’ve know what the output will be because we always have the same inputs. Computer software wouldn’t be terribly interesting if it could only run specific, known, canned inputs. Fortunately, Python gives us several ways to bring data into our programs.\nThe simplest way to bring data into a Python program is to edit the program and change the values we assign to variables. This is sort of the reducto ad absurdum method, but honestly it isn’t a bad way to handle very small amounts of input. It’s even easier in Jupyter notebooks since the code is just sitting there looking at us, waiting to be edited. For values that aren’t going to change very often (your name, perhaps, or the chargeback account number for using some instrument, for instance) then just assigning a value to a variable and editing it every once and a while is a fine way to go.\nAnother way to get data into a Python program is to read it in from where the user is running the program. For doing this, Python provides a function called “input” which takes an optional argument, specifically a string that is printed as a prompt. Python then waits for the user to type something as a response. When they do, that string is returned to the calling program. Here’s a simple example:\n\n\nPlease enter your name Erik\n\n\nHello, Erik\n\n\nWhen the above code runs, the prompt “Please enter your name” is displayed right below the code cell and a text entry box is placed beside it. When you enter your name, it greets you.\nIf we were running this tiny little snippet of code as a regular program, the interaction would be in the terminal emulator window that we ran the program in. Because this is running in Jupyter, though, the interaction is directly in the notebook. The prompt and the entry blank occur just below the running code cell.\nWhat will happen when we run the following?\n\n\nEnter a number between 4 and 8 5.25\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In [4], line 2\n      1 response = input(\"Enter a number between 4 and 8\")\n----&gt; 2 new_value = response + 6.5\n      3 print(new_value)\n\nTypeError: can only concatenate str (not \"float\") to str\n\n\n\nWow! Python couldn’t run that and it “threw an error”. We’ll examine Python’s error handling facilities later, but for now we’ll just assume that means it came to a screeching halt. Looking at the error message, it seems there is some problem with trying to add a real number (a floting point number) to a string."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#type-casting",
    "href": "preliminaries/PRE100/index.html#type-casting",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Type Casting",
    "text": "Type Casting\ninput() prompts the user and returns the string they entered, but what if we want the user to enter a number? What do we do then? The answer is we’ll use a process known as type casting. The act of type casting is no more than converting information from one type to another.\nThere are three very useful functions for type casting: int(), float(), and str(). Let’s see them in action…\n\n\n16.454\n34543456\n4\n\n\nWhat did the above do? First, it converted the string “9.9” (literally, three characters… it’s a string) to a “float” (a floating point number, some languages will call that a real number). The second example takes a string of 8 characters and interprets them as an integer. That value is what gets returned and stored in our variable. Finally, we copmute the number 4 by adding 2+2, and then we let the str() function convert that to a single character long string having just the character “4”.\nBy now we know enough to be able to ask the user for a number and get something back that we can actually do math with.\nThere’s an even easier way, though. Just like function composition worked when you took precalculus, the results of a Python function can be used as the argument to another. Hence:\n\n\nEnter a number between 17 and 34 26\n\n\n26.0\n\n\nSometimes, function calls can be nested really deeply. Personally, when it comes time to debug code like that I find myself printing it out and coloring each level with a different highlighter pen."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#putting-it-together-while-loops-to-get-user-input",
    "href": "preliminaries/PRE100/index.html#putting-it-together-while-loops-to-get-user-input",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Putting it together: while loops to get user input",
    "text": "Putting it together: while loops to get user input\nThe great thing about a while statement is that it can loop zero times, one, two, or twelve trillion. Best of all, we don’t have to know how many ahead of time. We could do the following:\nprint(“Computing an average.”)\nsum=0.0 counter=0 data_point = float(input(“Enter a number, or enter negative num to stop”)) while data_point &gt;= 0.0: sum = sum+data_point counter = counter+1 data_point = float(input(“Enter a number, or enter negative num to stop”))\nprint(“Average value is”, sum/counter)\nWhen we run the code above, we’re prompted to keep entering numbers until we finally enter -999. Each time it goes through the loop it keeps track of the running total of the numbers and the count of how many numbers have been entered. Once it’s done, it divides the total by the count and displays that as the average.\nLet’s step through what happens when the user enters 1, 2, 3, and -999: 1. The sum and counter variables are initialized to zero. 1. The user is prompted to enter a number, possibly a negative number to indicate no more data, and that input is type cast to a floating point number. 1. The while loop’s condition will be met any time a positive number was input (greater than or equal to zero). 1 is a positive number, so run the loop body. 1. This first time through, we’ll add the 1 that was input to our running total, which is now 1. 1. And increment the count, now equal to 1. 1. AND PROMPT THE USER FOR ANOTHER NUMBER!!! 1. Back at the while statement again, we check the condition and, yes, 2 is a positive number, so we run the loop’s code block. 1. Update the sum and count, and then… 1. PROMPT THE USER FOR ANOTHER VALUE!!! 1. Running the while statement again, the user entered 3, and 3 is positive, so the clode block will be executed. 1. Update the sum (now 6) and count (now 3). 1. Prompt for another number 1. Back at the while statement, we check and see that -999 is not a positive number, so we skip the code block and resume by running whatever follows it. 1. Having exited the while loop entirely, print out the average value by dividing sum/count.\nAll the boldface and all-capitals lines above are there to emphasize how important it is to make sure your while loop isn’t just checking the same thing over and over. If we didn’t get a new number from the user each time through, the value of data_point would never change. That would result in an infinite loop, causing Python to never be able to complete the code in that cell. If it ever happens to you, and it probably will, the “Interrupt Kernel” command on JupyterLab’s Kernel menu will stop the looping and let you get back to work.\nThe while loop is certainly versatile… it can be used any time you need to do something repeatedly. If you know how many times you need to have the code block execute, either when you write the code or when it’s running, then keep a variable that is incremented in the block every time and exit the while loop when the counter hits the right number.\nWhere while loops really shine is when it’s impossible to know ahead of time how many times the code block should run. The example above, where we keep accepting numbers until the user signals there aren’t any more, there’s no way to know how many times to execute that loop until we see a negative number. In a case like that, the while loop is the only practical solution.\nSo if while loops are so great and solve every problem, why do we need anything else? The big reason is expressiveness: they can be a little awkward to understand, especially when you’re looking at someone else’s code. Having the conditional test separated from the action that establishes when to stop makes it a little awkward to understand (or debug!) someone else’s code. This is especially true when we need to step through something by unusual increments.\nSo what are we to do in these cases?"
  },
  {
    "objectID": "preliminaries/PRE100/index.html#for-loops",
    "href": "preliminaries/PRE100/index.html#for-loops",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "For Loops",
    "text": "For Loops\nThe for loop is quite similar to the while loop. The difference is that for loops are controlled by a count whereas while loops are controlled by a condition.\nLet’s start with an example.\n\n\n1\n2\n3\n\n\nThat is the simplest for loop you’ll see. Let’s look at the pieces. 1. The for statement itself 2. The name of the target variable whose value will be changing as the loop runs (“the_value” in this case”) 3. “in” - and if this reminds you of set membership then you’re on to something 4. “range()” - this is an example of an iterable, which means “something that can be stepped through”. 5. The colon… the one I forget 50% of the time. 6. The code block, in this case just a print statement.\nMost of the time, fairly close to “always”, the code block will take advantage of the target variable changing each time through. In our example, “the_value” is our target variable, as it loops through it will take on the values 1 through 3, and the code block has a print statement that uses it.\nBefore we examine the range() function, let’s take a look at another iterable. We’ll talk about lists in a later lesson, but for now we can just wave our hands around and understand enough for the moment.\n\n\nThe sample weighed 143.6 grams.\nThe sample weighed 141.9 grams.\nThe sample weighed 139.4 grams.\nThe sample weighed 144.23219 grams.\n\n\nYou can use the target variable as many times as you want to in the code block.\nNow let’s take a more detailed look at the range() function. In its most basic form it takes one argument - the stop value.\n\n\n0\n1\n2\n3\n\n\nThis single-argument form starts at zero, counts up by one each time, and doesn’t include the stop value. This is different from every other programming language you’ll ever encounter. It’s just one of those things.\nWe’ve already seen the two-argument form. It takes a starting value and a stopping value, and iterates by one from the start until the last value that is less than the stop.\n\n\n7\n8\n9\n\n\nAnd there’s even a three-argument form. The third argument is the amount to step by.\n\n\n12\n15\n18\n\n\nThe step size doesn’t have to be a positive number…\n\n\n6\n4\n2\n0\n-2\n\n\nIn case you’re curious, the step size cannot be zero. If you really want an infinite loop, and there are cases where it makes sense, you have to use a while loop instead.\nAs a general rule, any place where you can use an explicit value (a literal) you can use a variable. Arguments to a for loop are no exception:\n\n\nwhere should we start?  13\nwhere should we run right up to and stop just short of it?  15\nwhat should we step by?  2\n\n\n13\n\n\nIf we need to do something a specific number of times, we need to pay attention to our starting and stopping conditions. I’ve messed this up so many times I know now to be careful. You’ve been warned.\n\n\nHow many numbers would you like to total up?  3\nEnter a number  4\nEnter a number  5\n\n\nThey add up to 9\n\n\nNotice something wrong? If you ask it to total 3 numbers, it only prompts for two of them. There are a couple of ways to solve this. The easiest is to just use the one-argument form of range().\n\n\nHow many numbers would you like to total up?  3\nEnter a number  4\nEnter a number  5\nEnter a number  6\n\n\nThey add up to 15\n\n\nThat offers a little insight into why Python has it’s funny “up to but not including” semantics: zero is a perfectly legitimate number and a very natural starting point.\nThe only problem with the single-argument method is that the values that the target variable goes through include zero. This may or may not be a problem if that value is used inside the code block. If you really need to count from one instead of zero, you can increment the stopping value:\n\n\nHow many numbers would you like to total up?  3\nEnter a number  4\nEnter a number  5\nEnter a number  6\n\n\nThey add up to 15\n\n\nAnd that behaved just like we expected.\nYou may have noticed a pattern already. We frequently need to compute a new value for an existing variable. What we’ve done so far has been along the lines of grand_total = grand_total + new_reading. Python gives us a shorthand way to write that. We could instead express that as grand_total += new_reading. There is no space between the plus and equals signs. The only reason this exists is to save you some typing. As you might expect, there are a few more of these Augmented Assignment Operators…\n\n\n\nOperator\nExample\nEquivalent\n\n\n\n\n+=\ncount += 1\ncount = count + 1\n\n\n-=\nx -= offset\nx = x - offset\n\n\n*=\nproduct *= val\nproduct = product * val\n\n\n/=\ny /= 3\ny = y / 3\n\n\n%=\nval %= 2\nval = val % 2\n\n\n\nOut of all of them, += is far and away the most commonly used one."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#nested-loops",
    "href": "preliminaries/PRE100/index.html#nested-loops",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Nested Loops",
    "text": "Nested Loops\nYou know what’s fun to put in a loop’s code block? Another loop! Best of all, it comes in pretty handy when dealing with high-dimensional data. Plenty of algorithms rely on nested loops, too. Take a look at this:\n\n\nx= 0  y= 0\nx= 0  y= 1\nx= 0  y= 2\nx= 0  y= 3\nx= 1  y= 0\nx= 1  y= 1\nx= 1  y= 2\nx= 1  y= 3\nx= 2  y= 0\nx= 2  y= 1\nx= 2  y= 2\nx= 2  y= 3\nx= 3  y= 0\nx= 3  y= 1\nx= 3  y= 2\nx= 3  y= 3\nx= 4  y= 0\nx= 4  y= 1\nx= 4  y= 2\nx= 4  y= 3\n\n\nWhat’s going on here? Initially, the outer loop, the one that iterates zero through four and assigns it’s value to x, runs. When it starts running its code block for the x=0 pass, the for loop for the y variable starts. ‘y’ assumes the values 0 through 3, so the first four lines printed out are for x=0, y=0, then x=0, y=1, and so on through x=0, y=3. Once that inner for loop completes, the outer for loop gets to iterate again. Now the inside for loop runs again, only this time we have x=1. That’s why the next four lines are “x=1, y=0” through “x=1, y=3”. Every time the outer loop runs another iteration, the inner loop gets to run all the way from start to finish.\nIn later lessons, we’ll have a few opportunities to play with nested loops. In fact, we’ll get to do that in the very next lesson: Functions!"
  },
  {
    "objectID": "preliminaries/PRE100/index.html#encapsulation",
    "href": "preliminaries/PRE100/index.html#encapsulation",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Encapsulation",
    "text": "Encapsulation\nFunctions are useful in programming for the same reason they’re useful in math - ours encapsulate a chunk of code so you don’t have to think about what is in it every time. Imagine how tedious it would be to write a program that needed to compute cosine in a lot of different places in the code. You could, I suppose, type in a Taylor series expansion for cosine in each of the places where we need to compute a cosign. That would be irritating, error prone, and confusing to anyone else who has to read it. Instead, we can write a function exactly once to compute cosine and then call that function from many places in our code. Once we have the function tested and debugged, we don’t have to think about it again. That frees up mental energy for more productive uses.\nFunctions can be classified into one of two types. Void Functions exist for encapsulation and don’t actually return a value. print() is an example of a void function. Value-Returning Functions, as the name strongly implies, return a value to the calling code. inductiveReactance() is an example of one.\nHere’s another example. This time, we’ll define a function that calls another function.\n\n\nArea of a circle with a radius of 2 is 12.56636\n\n\nWe defined a function to compute the area of a circle. It needed to square a number and so we decided to write a function to do that. Functions can call other functions ad infinitum. In fact, functions can even call themselves! When that happens the function is said to be recursive. Recursive functions are very useful for solving some hard problems but they’re a little beyond an introductory module like this one."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#function-and-variable-naming",
    "href": "preliminaries/PRE100/index.html#function-and-variable-naming",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Function (and Variable) Naming",
    "text": "Function (and Variable) Naming\nWhat kinds of names can we use for functions? The same ones we can use for variables! More specifically, * No keywords (e.g., False is invalid) * No spaces (e.g., my function is invalid) * The first character must be: * a-z, A-Z, or _ (the underscore character) * No numbers (e.g., 1st_function is invalid) * After the first character, the following are allowed: * a-z, A-Z, _, and 0-9 * No other symbols (e.g., get_room&board is invalid)\nAs a widely agreed upon best practice, names should be meaningful and be composed of lowercase characters with underscores as separators."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#function-arguments",
    "href": "preliminaries/PRE100/index.html#function-arguments",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Function Arguments",
    "text": "Function Arguments\nInput Parameters to functions are called arguments. They are the primary and best way to put information into a function, and definitely the way that causes the fewest problems. Arguments to a function in Python are mostly analagous to what we’re used to in math, but of course Python has some extensions.\nA function can have any number of arguments, including zero. “A function of zero arguments” might sound like a mathematician’s idea of “humor”, but it can actually make sense in programming. Sometimes you just need to encapsulate part of your code so you don’t have to worry with it again. For instance:\n\n\n==============================\n==============================\nGreetings, User. I'll start \nloading the instrument config\nfiles and opening connections\nto them. It'll take a minute.\n==============================\n==============================\n\n\nNow the code to print that banner is hidden away inside a function we’ll never have to look at again. Less mental clutter means fewer bugs.\nAnd for the sake of completeness, functions can also take one or more arguments:\n\n\nThe race was 6.213712 miles long and my ankles were hurting the ENTIRE way.\nThe polynomial evaluates to: 1284.04\n\n\nWhen arguments are passed into a function, they become parameter variables and can be referred to inside the function just like any other variable. This handy because the variables inside a function are called local variables and they have special properties: nothing outside of the function can modify their value, they’re destroyed and re-created every time the function is called, and these local variables supercede any outside variables with the same name.\nTake a look for yourself:\n\n\nTwice the wavelength is 40\nTwice the wavelength is 40\nTwice the wavelength is 40\n\n\nDoes that seem odd to you? What happened is this: four lines from the bottom we created a variable named “wavelength” and set it to 20. We then called the function to print it out doubled. We passed the global variable “wavelength” to our function which took it as its only argument. That argument became a parameter variable that was coincidentally named “wavelength”. That “wavelength” parameter variable has nothing to do with the “wavelength” variable in the main part of the program. Our function doubles that parameter variable and prints it out. At that point, the function completes and the flow of control goes back to the main body.\nThe next time our function is called an entirely new, fresh set of variables and parameter variables is created. This is important - it means that if we call the function with the same value every time then we always get the same result. Functions are unable to save their “state”. Like a football player on a stretcher, they have no memory of what happened before.\n(OK, yes, there are ways for them to save their state. Sometimes it’s unavoidable and you just have to do it, but doing so makes more places for bugs to creep into your programs and makes it harder to understand later. Try to avoid it. We’ll talk about it later.)"
  },
  {
    "objectID": "preliminaries/PRE100/index.html#variable-scope",
    "href": "preliminaries/PRE100/index.html#variable-scope",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Variable Scope",
    "text": "Variable Scope\nThe degree to which your programs can “see” a variable is called scope. There are two levels of scope in most Python programming:\n\nGlobal Scope\n\nDefined in main Python file\nOutside of ANY function\nTry to avoid these!\n\nConsidered poor design\nDangerous to use: any part of the program anywhere can change these\nBug Magnet!\n\n\nLocal Scope\n\nVariables defined within a function\nOnly visible and useable from inside their own function!\nUse these if at all possible.\n\n\nThe danger in global variables comes from two things. The first is the fact that the value can be changed anywhere in your program, either in the main program or inside of a function, and it’s devilishly hard to keep track of where that might be.\nThe second danger is more subtle. When a function saves a value into a global variable, the function is now said to have side effects. Side effects break the idea of isolation that functions are meant to give us. Imagine a mathematical function, such as tangent, if it had side effects. Calling tan(.0125) would not only result in the tangent of .0125, but it would have some other effect on some unrelated part of math. Imagine if calling tan caused your coordinate system to change every time? That would be insane.\nIt gets worse, though. What if our tangent function also read from a global variable and changed its behavior based on that. Then each time we called tan(.0125) we might get a different value.\nIn other words, we basically broke math.\nSimilarly, when we write programs, if our functions have side effects then we’ve complicated them tremendously. And more complication means more places for bugs to sneak into our code and they’ll also be harder to find.\nAs an aside, there is a style of programming that eliminates global variables and, to an extent, even local variables. It’s called functional programming, and Python has some support for that style. There is usually more than one way to do anything in Python, and experienced Pythonistas will usually try to choose the most Pythonic way. Part of being in Pythonic style means to use (at least partially) a functional style."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#constants",
    "href": "preliminaries/PRE100/index.html#constants",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Constants",
    "text": "Constants\nThere is an exception to the “no globals” rule: Constants. Just like in math, a constant is given a value once and never changed again. “Never changing” means “no side effects” so everything is OK. It is good practice to define your constants using ALL CAPITAL LETTERS.\n\n\n1.9878e-19"
  },
  {
    "objectID": "preliminaries/PRE100/index.html#abstraction",
    "href": "preliminaries/PRE100/index.html#abstraction",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Abstraction",
    "text": "Abstraction\nA valuable property of functions is how they isolate the code and variables inside of them from being manipulated elsewhere in your software. A consequence of that is their ability to “hide” detail from us. We’ve already talked about writing a function, debugging it, and never having to look at the code inside of it again. What is every bit as useful, if not more so, is using functions to provide abstraction.\nAbstraction is something we’ve used every day even if we haven’t thought it. Remember learning math? You started off counting things, and yes, that counts as math. If you had four bottle caps in one hand and three in the other, you could toss them all on the table, count them, and know that you have seven in total.\nThere are two problems with having to count everything. One is that the amount of stuff can get big in a hurry. Try using two hands and table to count sand grains. The other problem is that if there are any insights to be had, it’s hard to find them when you’re stuck down in the details. Fortunately, we learned arithmetic.\nArithmetic is great. We don’t have to deal with handfuls of stuff anymore. We can just use numbers and operators and get an answer without a bunch of messing around. We can start to see patterns we never would have just tossing bottle caps on the table. If we need to add 12 to something, we can instead add 10 and then add 2 more. This is so handy. Of course, it would be nice if we could just do something to analyze entire families of arithmetic problems.\nAlgebra lets us analyze entire families of arithmetic problems. We don’t have to fool with numbers if we don’t have to - we can just substitute variables in their place. We’ve hidden some of the complexity, like the petty little details of numbers, and abstracted that complexity away.\nSimilarly, a lot of problem solving is perfectly amenable to using abstraction. Let’s write a bit of code to run an experiment…\nThat function is a (admittedly fanciful) representation of running an experiment. It makes sense, anyone can understand it, and if there’s a bug in there then it’s going to be really obvious. The only problem: if we try to run it, it’ll crash because those other functions haven’t been defined yet. Shall we fix that?\nNotice how the program is broken up into several functions? The best part is that you don’t have to keep everything in your head. All you have to remember is the part you’re working on. Smaller pieces, fewer bugs."
  },
  {
    "objectID": "preliminaries/PRE100/index.html#modules",
    "href": "preliminaries/PRE100/index.html#modules",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Modules",
    "text": "Modules\nOne reason Python has become so popular is the sheer amount of code that has been written in it and made available for public use. We’ve seen a few functions already that were built in to Python - int(), float(), and str(), for example - but there are many tens of thousands of modules that are freely available for use in your own software. Just picking five common ones at random:\n\nmath\nrandom\nos\nPyMySql\npsycopg\n\nThe first two contain functions for general-purpose math and for producing random numbers. The “os” module interfaces Python with the operating system the code is running on. PyMySql and psycopg provide connectivity to relational databases.\nRemember at the beginning of this lesson when we wrote a function to calculate inductive reactance? I put the value of pi in there as 3.14159, but that really isn’t anywhere near enough digits for some problems. Let’s fix that:\n\n\n3.141592653589793\n\n\nThere are two things to note here. First, the keyword import is used to tell Python to go find a module with the right name and load it. The name we want it to find is the word right after the import. And secondly, just looking at the output we can see that there are a lot more digits than when we did something by hand in our Inductive Impedance example (top of this page). In general, using a module that was (a) written by someone else and (b) is widely used and has been checked by a lot of people is going to avoid a lot of bugs. For instance, I would never code my own Fast Fourier Transform. Instead, I would use the one in the “numpy” module. I know how easy it is to make a mistake and I trust their work a lot more than my own. They have tens or hundreds of thousands of users and scores of developers. I have… a copy of Numerical Recipes that’s old enough to run for President.\nSince we used the “math” module already, here’s a very incomplete list of what is in there: * sin(), cos(), tan(), acos(), asin(), atan()… - “acos” is “arc cosine”, etc. * log(), log10(), sqrt() - square root * radians(), degrees() - converts between them\nAnd lots more stuff. How do you know what’s in it? Go to the online documentation: https://docs.python.org/3/library/math.html\n\nRandom Numbers\nAnother module that is heavily used is “random”. It generates random numbers, yes, but it can also do things like take a list of things and shuffle them randomly.\n\n\nThe random integer between 10 and 100 was: 20\nThe random float between 0 and 1 is: 0.6474502367565016\n\n\nThere are more functions available in the “random” module, including ones to select a real number from a non-uniform distribution. Take a look at https://docs.python.org/3/library/random.html\nHere’s a slightly more complicated example:\n\n\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nDon't feel bad... proposal number 24 didn't get funded either.\nProposal number 23 was funded!\nDon't feel bad... proposal number 24 didn't get funded either.\n\n\n\nLet’s try out what we’ve learned so far. Use the next code cell to write a bit of Python that simulates rolling a pair of dice and adds the two values. Print the value out.\nLet’s add to that… add a loop so that we keep doing that over and over until we get the same sum twice in a row. Some questions to ask yourself are “What kind of loop do I need?” and “How can I compare what happened between two different loop iterations?”"
  },
  {
    "objectID": "preliminaries/PRE100/index.html#files",
    "href": "preliminaries/PRE100/index.html#files",
    "title": "Programming Essentials - Python Programming and Jupyter Notebooks (PE100)",
    "section": "Files",
    "text": "Files\nPractically everyone is more-or-less familiar with the idea of a file, even if fairly few people know how they work. We’re going to ignore a lot of details for the moment and say this: a file is a long-lasting collection of bytes. It has a first byte, a last byte, and every one in between stays in the same order.\nThis begs the question “What is a byte?” A byte is just a small number from 0 to 255 (inclusive). We can assign meaning to those numbers, and if we’re smart about how we do it then we can represent any information a computer can process as long as we use enough of these bytes.\nWe like to think of files as being one of two types: binary files and text files. Binary files are pure data. We decide how to write bytes to a file to represent data. Then when we’re ready to read it in again, we read the bytes, process them somehow, and reconstruct the original data. It’s a great technique - it’s fast and efficient.\nWe won’t be talking about binary files in this notebook or even in this module. Fifteen years ago we wouldn’t have had a choice, we would have had to. These days, it’s unusual to have to deal with binary files, especially in Python, because there is so often a library function already available to do the work for us.\nText files, on the other hand, are probably something you’re already familar with - they are what you get when you edit a “plain text” file in “notepad” or “textedit”. In a text file, every one of the letter, number, and punctuation mark characters is assigned its own number. For instance, capital “A” is 65. “B” is 66. Not that it should ever matter, but here’s a complete list and then some!\nLet’s say you open an editor and type “CAT”. When you save that to a file, there will be a file that is three bytes long and contains the three bytes 67, 65, and 84. Actually there will usually be a fourth byte, 10, which is the character you get when you press “Enter” or “Return”.\nFor now, at least for a few minutes, we’re going to pretend the only language on earth is English. We’ll talk about other languages when we talk about networks.\nIt’s about time for an example, don’t you think?\nThree lines of code was all it took to create a file, write to it, and tidy up after ourselves. What does each of those lines do?\nmy_file_object = open(\"/tmp/first_file.txt\", \"w\")\nmy_file_object is an object variable. Think of an object as a way to store data in a variable along with some functions that only make sense to that data. They hide a lot of complexity from us. A file object is one that keeps track of a filename, how to get to it, and how to use it. It has some functions built in to it to help us do things to the file.\nPython gives us the function “open”. It gets a file ready to be used by our code. It takes two arguments. The first is the file’s name, and the second is the mode we want to use the file in. In our example, we specified that the file’s name was “first_file.txt” and that it was in the “/tmp” directory. Then in the second argument we specified “w”, meaning we wanted to write to the file. The “w” mode will cause the file to be created if it didn’t already exist. If it did already exist, on the other hand, all the contents of it will be deleted and we’ll start writing from the beginning just as if the file was created from scratch. We’ll see more modes as we go.\nmy_file_object.write(\"First Post!\")\nThis line uses one of those functions that are tucked away inside an object. In this case, we’re calling the file object’s “write” function. It does what we expect - it takes its argument, in this case “First Post!”, and causes it to be written to disk byte by byte.\nmy_file_object.close()\nFinally, we call one more of the file object’s functions: close. When we run this, Python tells the operating system “Hey, we’re done with the file. You can get rid of any of the tedious housekeeping data that operating systems keep behind the scenes!”\nClosing files is considered “good programming hygene”. You’re allowed 1024 file objects to be open and connected to files in one program on the CLASSE cluster of computers. I’ll say from my experience: if you think you need that many, you’re probably doing something the wrong way.\nWriting files, then, is fairly easy. What about reading files? I’m glad you asked.\n\n\n'First Post!'\n\n\nYou can probably tell mostly how that worked just by looking at. We used the open() function again, but this time with a “r” for our mode. This means “read”. Also, this time we used read() instead of write(). The read() function reads in an entire file and saves it a string variable. Finally, we call close() again to close the file and tidy up after ourselves.\nNote that if the file is, say, 500 megabytes long, the string variable is going to be very, very large - roughly half a gigabyte. Python can handle this, but it may not be terribly convenient. If the file is more than 100-200 gigabytes, the CLASSE servers are probably not going to be able to handle. I say “probably” because there are a lot of factors at play.\nJust writing one line to a file is probably not very useful. Let’s try writing two lines:\nWhen we run that, it will open /tmp/first_file.txt for writing and it will delete anything already in it (that’s what the “w” means, remember?). Then it will write “First line written.” and “This is my second line.”.\nLet’s read the file again and prove to ourselves that it worked…\n\n\n'First line written.This is my second line.'\n\n\nOh no! The two lines ran together!\nAnd that is one of the first differences we’ll see between write() and print(). Print() always adds a newline character after it prints out anything. Remember when I said there would usually be a byte at the end of a line, represented by the number 10? This character is called “newline” and it, as the name implies, marks where a new line starts.\nIn all likelihood, when we do two write() statements like we did, we want to put a newline character in the file to make it into two lines. Fortunately, there are several ways to do that. Here are two of them.\nThe first way is simple and direct - call write() three times instead of two and put a newline in there “by hand”, as it were:\n\n\n'First line written.\\nThis is my second line.'\n\n\nThe output looks a little strange. We put an extra write() function call, but we gave it an odd looking argument - . That is a backslash (usually between the Enter and the backspace keys on a US keyboard) immediately followed by a lowercase “n”. The combination together means “newline character”. This much is fairly straightforward.\nNext we read the contents of the file. This is just like before.\nFinally, and this is where things take an unexpected turn, we evaluate the_contents and let Jupyter print that out for us. And when Jupyter does that, we see the “” there. It seems like Python didn’t convert those two characters to a newline, just sticking them in there as-is, and still left us with one long line. But is that true? Has Python foresaken us?\nRun the code in the next cell:\n\n\nFirst line written.\nThis is my second line.\n\n\nSalvation! print() did the right thing. This is a key difference between just typing a variable or an expression at the end of a cell and letting Python evaluate it versus putting a print() in there and having absolute control over what gets sent to the notebook and on to the screen.\nThis also illustrates something else important and useful: all of the code cells in this notebook are being run by the same Python “interpreter”. This means if we set a variable to a value in one cell, we will see the same value stored in that variable in other cells. That’s how we were able to print what was stored in the_contents in the cell above even though we had set its value to the file contents two cells above that.\nIf a file only has a line or two, it’s not a big deal dealing with that with string functions. If a file has millions of lines, then it becomes a bit of a hassle. We need a way to read a file one line at a time. Fortunately, there’s readline():\n\n\nFirst line written.\n\nThis is my second line.\n\n\nThis does almost what we expect: it reads both lines from the file, one at a time, and prints them out. The only snag is that blank space between the lines. What has happened? It turns out readline() reads the entire line, even the newline character at the end. We can see this if we evaluate the string instead of just printing it:\n\n\n'First line written.\\n'\n\n\nThere’s that \\n again! What about the second line?\n\n\n'This is my second line.'\n\n\nWhen readline() reads a line, it includes the newline character at the end unless it reaches the end of the file and the file didn’t end with a newline.\nIt’s rare that we would want to read a bunch of lines in a file with the newlines included. That’s just not something we do very often, and practically never in scientific software. We’ll almost always want to trim off the newline character. And for that, we have the rstrip() function. It takes a string, strips off any newlines on the right side of it, and returns that cleaned-up string. rstrip() does that for the right side of the string, lstrip() cleans up the left side (the beginning of the string) and strip() goes crazy and does both ends at the same time.\nLet’s try it:\n\n\nFirst line written.\nThis is my second line.\n\n\nWhat’s going on here? A couple of things. The first thing to note is that rstrip() and its close companions lstrip() and strip() take one argument, which is the character to be stripped. Practically always we’ll want to get rid of the trailing newline character.\nThe other interesting things is how we called the rstrip() function in the first place. We gave the name of the string variable, a period, and the name of the function we were calling. This is just like how we called the close() function on a file object. And in fact, strings are another kind of object in Python. We’ll see a lot more on this later.\nHistorical note: The original programming language that had objects was named “Smalltalk”. In Smalltalk, the functions that were inside of objects were called “methods”. You’ll still hear people call them that. Later, the “C++” language came along and it called methods “member functions”. When programmers talk about the functions that are contained in objects, we’ll use either term interchangably, sometimes even switching in the middle of a sentence. We now return to your Python tutorial, already in progress…\nWe read both lines in the file we created. We were able to call readline() twice and know that we had all of our lines in the file because (1) we created the file ourselves and (2) we therefore knew it had precisely two lines. It wasn’t even too bad having to type those readline() and rstrip() lines twice. But what if we had a lot more lines? We would certainly want to use a loop.\nFor example, what do we do with a five-line file?\n\n\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nNo problem - we just use a for loop and do the readline() inside of it. It repeats the five times we asked for. In this case, after we read each line we cleaned it up a little and printed it.\nBut what if we can’t know the number of lines ahead of time? One approach is to have whatever program that creates the file write the number of lines that will be in it first. I won’t say this is a common approach in scientific software, but it isn’t exactly rare either.\n\n\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nThe overall scheme for this is probably obvious by now. In the first half, when we’re writing the file, we write a “5” on its own line, and then write five more lines. In the second part, we 1. Read the first line. 2. rstrip() to get rid of the trailing newline 3. Use the results of that as the argument to int(), converting that string (“5”) to an actual integer (5). 4. and finally go through a for loop that many times just like before\nMost of the time we won’t have the luxury of knowing how many lines are in a file, though. We need a way to read all of the lines, line by line, without limit. For that, we can loop through the file and quit when Python returns an empty string with not even a newline character.\n\n\n5\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nThe while loop behaved just like we expected - strat by reading a line, and then every time the line isn’t empty, print it out and read another line. When you finally hit a line that is completely empty, exit the while loop and close the file.\nLooping through a file all the way to the end is such a common thing to do, Python has a shortcut for doing it. Remember when we talked about a for loop iterating over an ordered set? A file can be thought of as an ordered set of strings. They’re not in alphabetical order, but rather they are ordered by line number. That means we can:\n\n\n5\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nAs you can imagine, reading isn’t the only file operation you can do with a loop. You can also write to a file that way. For instance,\n\n\n0\n1\n2\n3\n4\n5\n6\n\n\nFinally, we don’t have to erase the contents of a file every time we write to it. It’s perfectly normal to append to an existing file, and for that the “a” mode can be used with open().\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nWhen you use the append mode, the write() calls will either add to the existing file or, if it doesn’t already exist, it will be created and then written to as though we used the “w” mode.\nSo far in this lesson we’ve acted like everything just works perfectly every time. In reality, it’s not that neat. Filenames get typed in wrong, didks get full, and lines that are supposed to be numbers might contain text instead. Any of these problems is enough to bring our Python code to a grinding halt. Our next lesson is all about how to handle these problems and many, many more like them. We’re going to learn about Exceptions!"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.html",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.html",
    "title": "PE100-03: Decision Structures",
    "section": "",
    "text": "In the first lesson, everything we did was sequential programming. Statements are executed one after the other in exactly the order they’re written in. As long as there aren’t any errors, every statement will be executed."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.html#the-simplest-if-statement",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.html#the-simplest-if-statement",
    "title": "PE100-03: Decision Structures",
    "section": "The Simplest “if” Statement",
    "text": "The Simplest “if” Statement\nIn almost any real Jupyter notebook or standalone program we write, there will have to be places where different code paths are taken depending on what has happened leading up to there. Suppose we’re looking at absorption at one specific wavelength and we know that some of our instruments are a little bit too sensitive to changes in humidity. Maybe the first spectrometer has some insulation that is just a little too porous and reads a bit high, but the second one is even worse. We have calibration constants we can apply, but we have to apply the right constant for each individual instrument.\n\nspectrometer_number = 1                                                        \nreading = 7.00041                                                              \n                                                                               \nif spectrometer_number == 1:                                                   \n    useful_result = reading * 1.077                                            \n                                                                               \nuseful_result\n\n7.539441569999999\n\n\nHere we have the first Decision Structure (also called control flow statement) that we’ll look at. Taking the above code apart, we see several important things.\n\nThis is an “if statement”.\nTesting to see if two things are equal is done with two equals signs, not one (==). There’s a historical reason for this, and it’s a good reason, but it always trips up newcomers. You have been warned. You’re welcome.\nThe last character on the if line is : (a colon ).\nThe “body” of the if statement, the part that is run if and only if the tested condition is met, is indented.\n\nIn the case of the above if statement, what the code does is check to see if we’re using spectrometer number 1 and if we are then we add 7.7% to the reading and save it in a variable called “useful_result”."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.html#else-the-catch-all-specialist",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.html#else-the-catch-all-specialist",
    "title": "PE100-03: Decision Structures",
    "section": "Else: the catch-all specialist",
    "text": "Else: the catch-all specialist\nIf that was all an if statement could do then it would be really useful. But that’s not all it can do. We need to do something reasonable when we get readings from the second instrument. Such as:\n\nspectrometer_number = 2                                                         \nreading = 7.00041                                                               \n                                                                                \nif spectrometer_number == 1:                                                    \n    useful_result = reading * 1.077                                             \nelse:                                                                           \n    useful_result = reading * 1.19\n\nuseful_result\n\n8.3304879\n\n\nHere we have added an “else clause”. The above code is interpreted as “check to see if we’re using spectrometer number 1 and if we are then we add 7.7% to the reading and save it in a variable called useful_result. Otherwise, set useful_result to whatever is saved in”reading” plus 19%.\nSo far, so good. But there’s more! Suppose we need to handle several of these not-quite-top-quality spectrometers. How do you suppose we could deal with that? We could resort to putting if-else statements inside if-else statements in sort of a brute force fashion…\n\nspectrometer_number = 3                                                         \nreading = 7.00041                                                               \n                                                                                \nif spectrometer_number == 1:                                                    \n    useful_result = reading * 1.077                                             \nelse:                                                                           \n    if spectrometer_number == 2:                                                \n        useful_result = reading * 1.19                                          \n    else:                                                                       \n        if spectrometer_number == 3:                                            \n            useful_result = reading * .92                                       \n                                                                                \nuseful_result\n\n6.4403771999999995\n\n\nThe above code looks a little intimidating, but all there is to it is just a series of if statements. The logic of it goes like this: “If the instrument number is 1, then adjust it 7.7% and we’re done. Otherwise, it must be some other instrument number, so run our else clause”. Then in the else clause, it does the same thing, except checking for the second instrument and adjusting by 19%. If there was nothing to do there (because the instrument number was 3) then we run the else clause of that second if statement. This else clause houses an if statement that checks to see if the instrument is number three. This time it is, so the body of the if statement is executed. We set useful_reading equal to 92% of reading."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.html#elif",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.html#elif",
    "title": "PE100-03: Decision Structures",
    "section": "Elif",
    "text": "Elif\nThis is fine if we only have three instruments, but what do we do if we have 20 of them? We could, in principle, type in 60 lines of code, but that would be tedious, error prone, and would take a while to read and find any mistakes. Of course there’s a better way.\nThat better way is the “elif” keyword.\nLet’s see an example with 5 instruments…\n\nspectrometer_number = 4                                                         \nreading = 7.00041                                                               \n                                                                                \nif spectrometer_number == 1:                                                    \n    useful_result = reading * 1.077                                             \nelif spectrometer_number == 2:                                                  \n    useful_result = reading * 1.19                                              \nelif spectrometer_number == 3:                                                  \n    useful_result = reading * .92                                               \nelif spectrometer_number == 4:                                                  \n    useful_result = reading * 1.03                                              \nelif spectrometer_number == 5:                                                  \n    useful_result = reading * 1.26                                              \nelse:                                                                           \n    useful_result = reading                                                     \n    print(\"Be careful!\")    \n                                                                                \nuseful_result\n\n7.210422299999999\n\n\nThe final else clause is the one that runs if no other clauses ran. If no clause’s conditional statement is true so no clause runs, whether it’s the if clause or any of the elif clauses, then the else clause runs. It’s really easy to spot else clauses even from across the room - they’re the ones that don’t have a conditional test.\nNote that the if, elif, and else lines must end with a colon. True confession time: I forget the colons about half the time. Python catches it as an error, I fix it, and life goes on."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.html#slightly-more-complicated",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.html#slightly-more-complicated",
    "title": "PE100-03: Decision Structures",
    "section": "Slightly More Complicated",
    "text": "Slightly More Complicated\nYou can run more than one line of code in response to the tested conditions, but they have to be indented the same amount:\n\nspectrometer_number = 103\nreading = 7.00041\n\nif spectrometer_number == 1:\n    useful_result = reading * 1.077\n    trustworthy = False\nelif spectrometer_number == 2:\n    useful_result = reading * 1.19\n    trustworthy = False\nelse:\n    useful_result = reading\n    trustworthy = True\n\nprint(useful_result, trustworthy)\n\n7.00041 True\n\n\nThere are four interesting things going on here. The first and most important thing to notice is that we’ve got more than one line of code running in response to an “if”, “elif”, or “else” clause. A collection of lines that should be run together as a whole is called a code block. Unlike many languages that mark the start and end of code blocks with special words or characters, Python just does it by using indentation. Everything that is indented the same amount is considered to be in the same code block. We’ll look at this in more detail in a few minutes.\nSecondly, we’ve added lines to set a variable named “trustworthy” to a value depending on whether we had to adjust the reading. Evidently, if we have to compensate for old, dry, cracking insulators then we don’t really trust the instrument.\nThe third interesting thing is the values True and False. These are “Boolean” values, and when we put them into the “trustworthy” variable then it takes on the Boolean type. There are only two values, True and False. The capitalization is important.\nThe fourth thing to notice is that we’re sending two values into the print statement and it’s printing both of them. In general, we can give the print statement any number of arguments, separated by commas, and it will print all of them separated by one space."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.html#conditional-aka-relational-operators",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.html#conditional-aka-relational-operators",
    "title": "PE100-03: Decision Structures",
    "section": "Conditional (aka Relational) Operators",
    "text": "Conditional (aka Relational) Operators\nThe conditional test in each part of an if statement is an expression that results in a Boolean value. So far, the only conditional operator (or relational operator) we’ve seen is ==. There are others, though. For the sake of completeness, I’ll include == here:\n\n\n\noperator\ntested condition\n\n\n\n\n==\nequals\n\n\n!=\nnot equals\n\n\n&gt;\ngreater than\n\n\n&gt;=\ngreater than or equal\n\n\n&lt;\nless than\n\n\n&lt;=\nless than or equal\n\n\n\n“Relational” has at least two meanings in computing. Relational Operators have nothing to do with Releational Databases.\n\nTry This\nFor each of the following code cells, decide what the result is, run the cell, and see how you did:\n\n5 &lt; 6\n\nTrue\n\n\n\n5.99 == 5.99\n\nTrue\n\n\n\n5 != 5.00\n\nFalse\n\n\n\n5+6 &lt; 11\n\nFalse\n\n\n\n6 * 6 &gt; 12 + 12 + 12\n\nFalse\n\n\nRelational operators also work with strings.\n\nname = \"Alice\"\nif name == \"Alice\":\n    print(\"equals Alice.\")\nif name != \"Bob\":\n    print(\"The person is not Bob.\")\nif \"Alice\" &lt; \"Bob\":\n    print(\"Alice comes before Bob in alphabetical order.\")\nif \"Alice\" &lt;= \"Alice\":\n    print(\"Alice comes before or in the same place as Alice in sorted order\")\nif \"Mary\" &gt; \"Mark\":\n    print('Working left to right, the M, the a, and the r match on')\n    print('both strings, but when we finally get to the y and the k, y comes')\n    print('after k in alphabetical order.')\n\nequals Alice.\nThe person is not Bob.\nAlice comes before Bob in alphabetical order.\nAlice comes before or in the same place as Alice in sorted order\nWorking left to right, the M, the a, and the r match on\nboth strings, but when we finally get to the y and the k, y comes\nafter k in alphabetical order.\n\n\nA couple words of caution: the comparisons are based on the ASCII codes for each character. The “A” in ASCII stands for “American”, and as you might expect that means it only works for English language text. If you need to handle other languages, even potentially, then there is a better way to do it and we’ll see that in the lesson on strings.\nAlso, Capital letters are always less than lowercase letters, and not in the way you might think. “A” is less than “Z”, as you might expect, but “Z” is greater than “a”. The numbers 0-9 are the lowest of all. Punctuation is sprinkled around and the only way to know for sure is to look up “ASCII Chart”."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.html#code-blocks",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.html#code-blocks",
    "title": "PE100-03: Decision Structures",
    "section": "Code Blocks",
    "text": "Code Blocks\nLet’s go back to that part about running several lines of code but they have to be indented the same amount. Python always runs “blocks” of code. That block might be as short as one line:\n\ncircumference = 40 * 3.14159\n\ncircumference\n\n125.6636\n\n\nor it might be arbitrarily long:\n\nheight = 6.01\nlength = 5.5\nwidth = 14.3\ndensity = 4.2\nvolume = height * width * length\nmass = volume * density\nenergy_per_gram = 761.3\neyebrow_altering_potential = mass * energy_per_gram\n\neyebrow_altering_potential\n\n1511396.1762899999\n\n\nWhether it was the one line example or the eight line one, Python will set out to run all of those lines in one shot, and as long as there aren’t any errors it’ll do it. These are known as code blocks.\nThe decision structures (again, also called control flow statements) in Python all do basically the same thing: they evaluate an expression and depending on whether it turns out True or False, they execute a code block in some manner. This means that wherever we can have a single line of code running in a decision structure we can have as many lines as we want.\nTake a look at the following example. For the four possible combinations of potentially_hazardous and explody, decide what would be printed out. Then try out the combinations and make sure you know why each combination was handled the way it was.\n\npotentially_hazardous = True\nexplody = True\n\nif potentially_hazardous and explody:\n    height = 6.01\n    length = 5.5\n    width = 14.3\n    density = 4.2\n    volume = height * width * length\n    mass = volume * density\n    energy_per_gram = 761.3\n    eyebrow_altering_potential_energy = mass * energy_per_gram\n    print(\"Total Available Kaboom (TAK) to ruin your day is\", eyebrow_altering_potential_energy)\nelif potentially_hazardous:\n    print(\"Not likely to go 'kaboom', but not something you want to casually eat, either.\")\n    print(\"I mean, unless you're feeling brave.\")\n    print(\"Even then, it's a bad idea.\")\nelif explody:\n    print(\"This is one of those things that will blow up but isn't actually hazardous.\")\n    print(\"I'm guessing it's a vinegar-and-baking-soda volcano.\")\nelse:\n    print(\"As far as we know, the material in quesion is no more\")\n    print(\"dangerous than takeout pizza.\")\n\nTotal Available Kaboom (TAK) to ruin your day is 1511396.1762899999\n\n\nDid you notice potentially_hazardous and explody? and is a boolean operator. We’ve seen the arithmetic operators already (+, -, *, /, etc.) and now here are the boolean operators. They’re named after Boolean algebra, the algebra of logic, and are used to make larger logical expressions from smaller ones. There are three boolean operators: and, or, and not.\nThe and operator evaluates to True if both of its arguments are True. The or operator evaluates to True if either or both of its arguments are true. The not operator takes only one argument and reverses it: not turns True into False and False into True.\n\nmedical_license = True\ndental_license = True\n\nif medical_license and dental_license:\n    print(\"Doctor of Medical Dentistry (DMD)\")\nelif dental_license and not medical_license:\n    print(\"Plain old dentist.\")\nelif not dental_license and medical_license:\n    print(\"Garden-variety doctor.\")\nelse:\n    print(\"No license at all. Run. Quickly.\")\n\nDoctor of Medical Dentistry (DMD)"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.html#coming-up-next-loops",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.html#coming-up-next-loops",
    "title": "PE100-03: Decision Structures",
    "section": "Coming Up Next: Loops",
    "text": "Coming Up Next: Loops\nAt this point, we’ve seen the most basic way to alter the flow of control in Python: the if statement. We can write Python code to solve non-trivial problems now, but there are still some things we need in order to use Python as a truly general-purpose language. In the next notebook we’re going to make our code do something over and over."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.out.html",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.out.html",
    "title": "PE100-03: Decision Structures",
    "section": "",
    "text": "In the first lesson, everything we did was sequential programming. Statements are executed one after the other in exactly the order they’re written in. As long as there aren’t any errors, every statement will be executed."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#the-simplest-if-statement",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#the-simplest-if-statement",
    "title": "PE100-03: Decision Structures",
    "section": "The Simplest “if” Statement",
    "text": "The Simplest “if” Statement\nIn almost any real Jupyter notebook or standalone program we write, there will have to be places where different code paths are taken depending on what has happened leading up to there. Suppose we’re looking at absorption at one specific wavelength and we know that some of our instruments are a little bit too sensitive to changes in humidity. Maybe the first spectrometer has some insulation that is just a little too porous and reads a bit high, but the second one is even worse. We have calibration constants we can apply, but we have to apply the right constant for each individual instrument.\n\nspectrometer_number = 1                                                        \nreading = 7.00041                                                              \n                                                                               \nif spectrometer_number == 1:                                                   \n    useful_result = reading * 1.077                                            \n                                                                               \nuseful_result\n\n7.539441569999999\n\n\nHere we have the first Decision Structure (also called control flow statement) that we’ll look at. Taking the above code apart, we see several important things.\n\nThis is an “if statement”.\nTesting to see if two things are equal is done with two equals signs, not one (==). There’s a historical reason for this, and it’s a good reason, but it always trips up newcomers. You have been warned. You’re welcome.\nThe last character on the if line is : (a colon ).\nThe “body” of the if statement, the part that is run if and only if the tested condition is met, is indented.\n\nIn the case of the above if statement, what the code does is check to see if we’re using spectrometer number 1 and if we are then we add 7.7% to the reading and save it in a variable called “useful_result”."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#else-the-catch-all-specialist",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#else-the-catch-all-specialist",
    "title": "PE100-03: Decision Structures",
    "section": "Else: the catch-all specialist",
    "text": "Else: the catch-all specialist\nIf that was all an if statement could do then it would be really useful. But that’s not all it can do. We need to do something reasonable when we get readings from the second instrument. Such as:\n\nspectrometer_number = 2                                                         \nreading = 7.00041                                                               \n                                                                                \nif spectrometer_number == 1:                                                    \n    useful_result = reading * 1.077                                             \nelse:                                                                           \n    useful_result = reading * 1.19\n\nuseful_result\n\n8.3304879\n\n\nHere we have added an “else clause”. The above code is interpreted as “check to see if we’re using spectrometer number 1 and if we are then we add 7.7% to the reading and save it in a variable called useful_result. Otherwise, set useful_result to whatever is saved in”reading” plus 19%.\nSo far, so good. But there’s more! Suppose we need to handle several of these not-quite-top-quality spectrometers. How do you suppose we could deal with that? We could resort to putting if-else statements inside if-else statements in sort of a brute force fashion…\n\nspectrometer_number = 3                                                         \nreading = 7.00041                                                               \n                                                                                \nif spectrometer_number == 1:                                                    \n    useful_result = reading * 1.077                                             \nelse:                                                                           \n    if spectrometer_number == 2:                                                \n        useful_result = reading * 1.19                                          \n    else:                                                                       \n        if spectrometer_number == 3:                                            \n            useful_result = reading * .92                                       \n                                                                                \nuseful_result\n\n6.4403771999999995\n\n\nThe above code looks a little intimidating, but all there is to it is just a series of if statements. The logic of it goes like this: “If the instrument number is 1, then adjust it 7.7% and we’re done. Otherwise, it must be some other instrument number, so run our else clause”. Then in the else clause, it does the same thing, except checking for the second instrument and adjusting by 19%. If there was nothing to do there (because the instrument number was 3) then we run the else clause of that second if statement. This else clause houses an if statement that checks to see if the instrument is number three. This time it is, so the body of the if statement is executed. We set useful_reading equal to 92% of reading."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#elif",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#elif",
    "title": "PE100-03: Decision Structures",
    "section": "Elif",
    "text": "Elif\nThis is fine if we only have three instruments, but what do we do if we have 20 of them? We could, in principle, type in 60 lines of code, but that would be tedious, error prone, and would take a while to read and find any mistakes. Of course there’s a better way.\nThat better way is the “elif” keyword.\nLet’s see an example with 5 instruments…\n\nspectrometer_number = 4                                                         \nreading = 7.00041                                                               \n                                                                                \nif spectrometer_number == 1:                                                    \n    useful_result = reading * 1.077                                             \nelif spectrometer_number == 2:                                                  \n    useful_result = reading * 1.19                                              \nelif spectrometer_number == 3:                                                  \n    useful_result = reading * .92                                               \nelif spectrometer_number == 4:                                                  \n    useful_result = reading * 1.03                                              \nelif spectrometer_number == 5:                                                  \n    useful_result = reading * 1.26                                              \nelse:                                                                           \n    useful_result = reading                                                     \n    print(\"Be careful!\")    \n                                                                                \nuseful_result\n\n7.210422299999999\n\n\nThe final else clause is the one that runs if no other clauses ran. If no clause’s conditional statement is true so no clause runs, whether it’s the if clause or any of the elif clauses, then the else clause runs. It’s really easy to spot else clauses even from across the room - they’re the ones that don’t have a conditional test.\nNote that the if, elif, and else lines must end with a colon. True confession time: I forget the colons about half the time. Python catches it as an error, I fix it, and life goes on."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#slightly-more-complicated",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#slightly-more-complicated",
    "title": "PE100-03: Decision Structures",
    "section": "Slightly More Complicated",
    "text": "Slightly More Complicated\nYou can run more than one line of code in response to the tested conditions, but they have to be indented the same amount:\n\nspectrometer_number = 103\nreading = 7.00041\n\nif spectrometer_number == 1:\n    useful_result = reading * 1.077\n    trustworthy = False\nelif spectrometer_number == 2:\n    useful_result = reading * 1.19\n    trustworthy = False\nelse:\n    useful_result = reading\n    trustworthy = True\n\nprint(useful_result, trustworthy)\n\n7.00041 True\n\n\nThere are four interesting things going on here. The first and most important thing to notice is that we’ve got more than one line of code running in response to an “if”, “elif”, or “else” clause. A collection of lines that should be run together as a whole is called a code block. Unlike many languages that mark the start and end of code blocks with special words or characters, Python just does it by using indentation. Everything that is indented the same amount is considered to be in the same code block. We’ll look at this in more detail in a few minutes.\nSecondly, we’ve added lines to set a variable named “trustworthy” to a value depending on whether we had to adjust the reading. Evidently, if we have to compensate for old, dry, cracking insulators then we don’t really trust the instrument.\nThe third interesting thing is the values True and False. These are “Boolean” values, and when we put them into the “trustworthy” variable then it takes on the Boolean type. There are only two values, True and False. The capitalization is important.\nThe fourth thing to notice is that we’re sending two values into the print statement and it’s printing both of them. In general, we can give the print statement any number of arguments, separated by commas, and it will print all of them separated by one space."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#conditional-aka-relational-operators",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#conditional-aka-relational-operators",
    "title": "PE100-03: Decision Structures",
    "section": "Conditional (aka Relational) Operators",
    "text": "Conditional (aka Relational) Operators\nThe conditional test in each part of an if statement is an expression that results in a Boolean value. So far, the only conditional operator (or relational operator) we’ve seen is ==. There are others, though. For the sake of completeness, I’ll include == here:\n\n\n\noperator\ntested condition\n\n\n\n\n==\nequals\n\n\n!=\nnot equals\n\n\n&gt;\ngreater than\n\n\n&gt;=\ngreater than or equal\n\n\n&lt;\nless than\n\n\n&lt;=\nless than or equal\n\n\n\n“Relational” has at least two meanings in computing. Relational Operators have nothing to do with Releational Databases.\n\nTry This\nFor each of the following code cells, decide what the result is, run the cell, and see how you did:\n\n5 &lt; 6\n\nTrue\n\n\n\n5.99 == 5.99\n\nTrue\n\n\n\n5 != 5.00\n\nFalse\n\n\n\n5+6 &lt; 11\n\nFalse\n\n\n\n6 * 6 &gt; 12 + 12 + 12\n\nFalse\n\n\nRelational operators also work with strings.\n\nname = \"Alice\"\nif name == \"Alice\":\n    print(\"equals Alice.\")\nif name != \"Bob\":\n    print(\"The person is not Bob.\")\nif \"Alice\" &lt; \"Bob\":\n    print(\"Alice comes before Bob in alphabetical order.\")\nif \"Alice\" &lt;= \"Alice\":\n    print(\"Alice comes before or in the same place as Alice in sorted order\")\nif \"Mary\" &gt; \"Mark\":\n    print('Working left to right, the M, the a, and the r match on')\n    print('both strings, but when we finally get to the y and the k, y comes')\n    print('after k in alphabetical order.')\n\nequals Alice.\nThe person is not Bob.\nAlice comes before Bob in alphabetical order.\nAlice comes before or in the same place as Alice in sorted order\nWorking left to right, the M, the a, and the r match on\nboth strings, but when we finally get to the y and the k, y comes\nafter k in alphabetical order.\n\n\nA couple words of caution: the comparisons are based on the ASCII codes for each character. The “A” in ASCII stands for “American”, and as you might expect that means it only works for English language text. If you need to handle other languages, even potentially, then there is a better way to do it and we’ll see that in the lesson on strings.\nAlso, Capital letters are always less than lowercase letters, and not in the way you might think. “A” is less than “Z”, as you might expect, but “Z” is greater than “a”. The numbers 0-9 are the lowest of all. Punctuation is sprinkled around and the only way to know for sure is to look up “ASCII Chart”."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#code-blocks",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#code-blocks",
    "title": "PE100-03: Decision Structures",
    "section": "Code Blocks",
    "text": "Code Blocks\nLet’s go back to that part about running several lines of code but they have to be indented the same amount. Python always runs “blocks” of code. That block might be as short as one line:\n\ncircumference = 40 * 3.14159\n\ncircumference\n\n125.6636\n\n\nor it might be arbitrarily long:\n\nheight = 6.01\nlength = 5.5\nwidth = 14.3\ndensity = 4.2\nvolume = height * width * length\nmass = volume * density\nenergy_per_gram = 761.3\neyebrow_altering_potential = mass * energy_per_gram\n\neyebrow_altering_potential\n\n1511396.1762899999\n\n\nWhether it was the one line example or the eight line one, Python will set out to run all of those lines in one shot, and as long as there aren’t any errors it’ll do it. These are known as code blocks.\nThe decision structures (again, also called control flow statements) in Python all do basically the same thing: they evaluate an expression and depending on whether it turns out True or False, they execute a code block in some manner. This means that wherever we can have a single line of code running in a decision structure we can have as many lines as we want.\nTake a look at the following example. For the four possible combinations of potentially_hazardous and explody, decide what would be printed out. Then try out the combinations and make sure you know why each combination was handled the way it was.\n\npotentially_hazardous = True\nexplody = True\n\nif potentially_hazardous and explody:\n    height = 6.01\n    length = 5.5\n    width = 14.3\n    density = 4.2\n    volume = height * width * length\n    mass = volume * density\n    energy_per_gram = 761.3\n    eyebrow_altering_potential_energy = mass * energy_per_gram\n    print(\"Total Available Kaboom (TAK) to ruin your day is\", eyebrow_altering_potential_energy)\nelif potentially_hazardous:\n    print(\"Not likely to go 'kaboom', but not something you want to casually eat, either.\")\n    print(\"I mean, unless you're feeling brave.\")\n    print(\"Even then, it's a bad idea.\")\nelif explody:\n    print(\"This is one of those things that will blow up but isn't actually hazardous.\")\n    print(\"I'm guessing it's a vinegar-and-baking-soda volcano.\")\nelse:\n    print(\"As far as we know, the material in quesion is no more\")\n    print(\"dangerous than takeout pizza.\")\n\nTotal Available Kaboom (TAK) to ruin your day is 1511396.1762899999\n\n\nDid you notice potentially_hazardous and explody? and is a boolean operator. We’ve seen the arithmetic operators already (+, -, *, /, etc.) and now here are the boolean operators. They’re named after Boolean algebra, the algebra of logic, and are used to make larger logical expressions from smaller ones. There are three boolean operators: and, or, and not.\nThe and operator evaluates to True if both of its arguments are True. The or operator evaluates to True if either or both of its arguments are true. The not operator takes only one argument and reverses it: not turns True into False and False into True.\n\nmedical_license = True\ndental_license = True\n\nif medical_license and dental_license:\n    print(\"Doctor of Medical Dentistry (DMD)\")\nelif dental_license and not medical_license:\n    print(\"Plain old dentist.\")\nelif not dental_license and medical_license:\n    print(\"Garden-variety doctor.\")\nelse:\n    print(\"No license at all. Run. Quickly.\")\n\nDoctor of Medical Dentistry (DMD)"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#coming-up-next-loops",
    "href": "preliminaries/PRE100/PE100-03DecisionStructures.out.html#coming-up-next-loops",
    "title": "PE100-03: Decision Structures",
    "section": "Coming Up Next: Loops",
    "text": "Coming Up Next: Loops\nAt this point, we’ve seen the most basic way to alter the flow of control in Python: the if statement. We can write Python code to solve non-trivial problems now, but there are still some things we need in order to use Python as a truly general-purpose language. In the next notebook we’re going to make our code do something over and over."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-06Files.html",
    "href": "preliminaries/PRE100/PE100-06Files.html",
    "title": "PE100-05: Files",
    "section": "",
    "text": "You can write a good deal of software that runs entirely inside Jupyter notebooks or that runs on the command line and only communicates through the screen and the keyboard. Sometimes, though, you have to do with files. It may not be practical to hardcode all your data into assignment statements in Python, or maybe you have to deal with a number of files and therefore you can’t use pipes. link to Sys Fundamentals page here\nWe’ve already seen two basic ways to do Input and Output (often referred to as “I/O”). We’ve used input() to read from the keyboard and print() to send output to the screen. Those functions work quite well, except you might have to do a lot of typing or deal with your output scrolling off the screen. In neither case is the data durable - it goes away as soon as the program is done or you close the Jupyter notebook.\nThe input() and print() functions are just the tip of the proverbial iceberg in terms of getting information in and out of running Python code. Some of our other options include: * GUI controls: text box, menu, dialog box… * Networks: HTTP, TCP/IP sockets, Infiniband… * Databases: Relational (SQL) and NoSQL * Other: cameras, microphones, speakers, LabView"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-06Files.html#files",
    "href": "preliminaries/PRE100/PE100-06Files.html#files",
    "title": "PE100-05: Files",
    "section": "Files",
    "text": "Files\nPractically everyone is more-or-less familiar with the idea of a file, even if fairly few people know how they work. We’re going to ignore a lot of details for the moment and say this: a file is a long-lasting collection of bytes. It has a first byte, a last byte, and every one in between stays in the same order.\nThis begs the question “What is a byte?” A byte is just a small number from 0 to 255 (inclusive). We can assign meaning to those numbers, and if we’re smart about how we do it then we can represent any information a computer can process as long as we use enough of these bytes.\nWe like to think of files as being one of two types: binary files and text files. Binary files are pure data. We decide how to write bytes to a file to represent data. Then when we’re ready to read it in again, we read the bytes, process them somehow, and reconstruct the original data. It’s a great technique - it’s fast and efficient.\nWe won’t be talking about binary files in this notebook or even in this module. Fifteen years ago we wouldn’t have had a choice, we would have had to. These days, it’s unusual to have to deal with binary files, especially in Python, because there is so often a library function already available to do the work for us.\nText files, on the other hand, are probably something you’re already familar with - they are what you get when you edit a “plain text” file in “notepad” or “textedit”. In a text file, every one of the letter, number, and punctuation mark characters is assigned its own number. For instance, capital “A” is 65. “B” is 66. Not that it should ever matter, but here’s a complete list and then some!\nLet’s say you open an editor and type “CAT”. When you save that to a file, there will be a file that is three bytes long and contains the three bytes 67, 65, and 84. Actually there will usually be a fourth byte, 10, which is the character you get when you press “Enter” or “Return”.\nFor now, at least for a few minutes, we’re going to pretend the only language on earth is English. We’ll talk about other languages when we talk about networks.\nIt’s about time for an example, don’t you think?\n\nmy_file_object = open(\"/tmp/first_file.txt\", \"w\")\nmy_file_object.write(\"First Post!\")\nmy_file_object.close()\n\nThree lines of code was all it took to create a file, write to it, and tidy up after ourselves. What does each of those lines do?\nmy_file_object = open(\"/tmp/first_file.txt\", \"w\")\nmy_file_object is an object variable. Think of an object as a way to store data in a variable along with some functions that only make sense to that data. They hide a lot of complexity from us. A file object is one that keeps track of a filename, how to get to it, and how to use it. It has some functions built in to it to help us do things to the file.\nPython gives us the function “open”. It gets a file ready to be used by our code. It takes two arguments. The first is the file’s name, and the second is the mode we want to use the file in. In our example, we specified that the file’s name was “first_file.txt” and that it was in the “/tmp” directory. Then in the second argument we specified “w”, meaning we wanted to write to the file. The “w” mode will cause the file to be created if it didn’t already exist. If it did already exist, on the other hand, all the contents of it will be deleted and we’ll start writing from the beginning just as if the file was created from scratch. We’ll see more modes as we go.\nmy_file_object.write(\"First Post!\")\nThis line uses one of those functions that are tucked away inside an object. In this case, we’re calling the file object’s “write” function. It does what we expect - it takes its argument, in this case “First Post!”, and causes it to be written to disk byte by byte.\nmy_file_object.close()\nFinally, we call one more of the file object’s functions: close. When we run this, Python tells the operating system “Hey, we’re done with the file. You can get rid of any of the tedious housekeeping data that operating systems keep behind the scenes!”\nClosing files is considered “good programming hygene”. You’re allowed 1024 file objects to be open and connected to files in one program on the CLASSE cluster of computers. I’ll say from my experience: if you think you need that many, you’re probably doing something the wrong way.\nWriting files, then, is fairly easy. What about reading files? I’m glad you asked.\n\ninput_file = open(\"/tmp/first_file.txt\",\"r\")\nthe_contents = input_file.read()\ninput_file.close()\n\nthe_contents\n\n'First Post!'\n\n\nYou can probably tell mostly how that worked just by looking at. We used the open() function again, but this time with a “r” for our mode. This means “read”. Also, this time we used read() instead of write(). The read() function reads in an entire file and saves it a string variable. Finally, we call close() again to close the file and tidy up after ourselves.\nNote that if the file is, say, 500 megabytes long, the string variable is going to be very, very large - roughly half a gigabyte. Python can handle this, but it may not be terribly convenient. If the file is more than 100-200 gigabytes, the CLASSE servers are probably not going to be able to handle. I say “probably” because there are a lot of factors at play.\nJust writing one line to a file is probably not very useful. Let’s try writing two lines:\n\nmy_file_object = open(\"/tmp/first_file.txt\", \"w\")\nmy_file_object.write(\"First line written.\")\nmy_file_object.write(\"This is my second line.\")\nmy_file_object.close()\n\nWhen we run that, it will open /tmp/first_file.txt for writing and it will delete anything already in it (that’s what the “w” means, remember?). Then it will write “First line written.” and “This is my second line.”.\nLet’s read the file again and prove to ourselves that it worked…\n\ninput_file = open(\"/tmp/first_file.txt\",\"r\")\nthe_contents = input_file.read()\ninput_file.close()\n\nthe_contents\n\n'First line written.This is my second line.'\n\n\nOh no! The two lines ran together!\nAnd that is one of the first differences we’ll see between write() and print(). Print() always adds a newline character after it prints out anything. Remember when I said there would usually be a byte at the end of a line, represented by the number 10? This character is called “newline” and it, as the name implies, marks where a new line starts.\nIn all likelihood, when we do two write() statements like we did, we want to put a newline character in the file to make it into two lines. Fortunately, there are several ways to do that. Here are two of them.\nThe first way is simple and direct - call write() three times instead of two and put a newline in there “by hand”, as it were:\n\nmy_file_object = open(\"/tmp/first_file.txt\", \"w\")\nmy_file_object.write(\"First line written.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"This is my second line.\")\nmy_file_object.close()\n\ninput_file = open(\"/tmp/first_file.txt\",\"r\")\nthe_contents = input_file.read()\ninput_file.close()\n\nthe_contents\n\n\n\n'First line written.\\nThis is my second line.'\n\n\nThe output looks a little strange. We put an extra write() function call, but we gave it an odd looking argument - . That is a backslash (usually between the Enter and the backspace keys on a US keyboard) immediately followed by a lowercase “n”. The combination together means “newline character”. This much is fairly straightforward.\nNext we read the contents of the file. This is just like before.\nFinally, and this is where things take an unexpected turn, we evaluate the_contents and let Jupyter print that out for us. And when Jupyter does that, we see the “” there. It seems like Python didn’t convert those two characters to a newline, just sticking them in there as-is, and still left us with one long line. But is that true? Has Python foresaken us?\nRun the code in the next cell:\n\nprint(the_contents)\n\nFirst line written.\nThis is my second line.\n\n\nSalvation! print() did the right thing. This is a key difference between just typing a variable or an expression at the end of a cell and letting Python evaluate it versus putting a print() in there and having absolute control over what gets sent to the notebook and on to the screen.\nThis also illustrates something else important and useful: all of the code cells in this notebook are being run by the same Python “interpreter”. This means if we set a variable to a value in one cell, we will see the same value stored in that variable in other cells. That’s how we were able to print what was stored in the_contents in the cell above even though we had set its value to the file contents two cells above that.\nIf a file only has a line or two, it’s not a big deal dealing with that with string functions. If a file has millions of lines, then it becomes a bit of a hassle. We need a way to read a file one line at a time. Fortunately, there’s readline():\n\ninput_file = open(\"/tmp/first_file.txt\",\"r\")\nline_one = input_file.readline()\nline_two = input_file.readline()\ninput_file.close()\n\nprint(line_one)\nprint(line_two)\n\nFirst line written.\n\nThis is my second line.\n\n\nThis does almost what we expect: it reads both lines from the file, one at a time, and prints them out. The only snag is that blank space between the lines. What has happened? It turns out readline() reads the entire line, even the newline character at the end. We can see this if we evaluate the string instead of just printing it:\n\nline_one\n\n'First line written.\\n'\n\n\nThere’s that \\n again! What about the second line?\n\nline_two\n\n'This is my second line.'\n\n\nWhen readline() reads a line, it includes the newline character at the end unless it reaches the end of the file and the file didn’t end with a newline.\nIt’s rare that we would want to read a bunch of lines in a file with the newlines included. That’s just not something we do very often, and practically never in scientific software. We’ll almost always want to trim off the newline character. And for that, we have the rstrip() function. It takes a string, strips off any newlines on the right side of it, and returns that cleaned-up string. rstrip() does that for the right side of the string, lstrip() cleans up the left side (the beginning of the string) and strip() goes crazy and does both ends at the same time.\nLet’s try it:\n\nclean_first_line = line_one.rstrip('\\n')\nclean_second_line = line_two.rstrip('\\n')\n\nprint(clean_first_line)\nprint(clean_second_line)\n\nFirst line written.\nThis is my second line.\n\n\nWhat’s going on here? A couple of things. The first thing to note is that rstrip() and its close companions lstrip() and strip() take one argument, which is the character to be stripped. Practically always we’ll want to get rid of the trailing newline character.\nThe other interesting things is how we called the rstrip() function in the first place. We gave the name of the string variable, a period, and the name of the function we were calling. This is just like how we called the close() function on a file object. And in fact, strings are another kind of object in Python. We’ll see a lot more on this later.\nHistorical note: The original programming language that had objects was named “Smalltalk”. In Smalltalk, the functions that were inside of objects were called “methods”. You’ll still hear people call them that. Later, the “C++” language came along and it called methods “member functions”. When programmers talk about the functions that are contained in objects, we’ll use either term interchangably, sometimes even switching in the middle of a sentence. We now return to your Python tutorial, already in progress…\nWe read both lines in the file we created. We were able to call readline() twice and know that we had all of our lines in the file because (1) we created the file ourselves and (2) we therefore knew it had precisely two lines. It wasn’t even too bad having to type those readline() and rstrip() lines twice. But what if we had a lot more lines? We would certainly want to use a loop.\nFor example, what do we do with a five-line file?\n\nmy_file_object = open(\"/tmp/five-liner.txt\", \"w\")\nmy_file_object.write(\"Line 1.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 2.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 3.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 4.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 5.\")\nmy_file_object.write('\\n')\nmy_file_object.close()\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\nfor i in range(5):\n    input_line = input_file.readline()\n    print(input_line.rstrip('\\n'))\n\ninput_file.close()\n\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nNo problem - we just use a for loop and do the readline() inside of it. It repeats the five times we asked for. In this case, after we read each line we cleaned it up a little and printed it.\nBut what if we can’t know the number of lines ahead of time? One approach is to have whatever program that creates the file write the number of lines that will be in it first. I won’t say this is a common approach in scientific software, but it isn’t exactly rare either.\n\nmy_file_object = open(\"/tmp/five-liner.txt\", \"w\")\nmy_file_object.write(\"5\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 1.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 2.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 3.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 4.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 5.\")\nmy_file_object.write('\\n')\nmy_file_object.close()\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\n\nfirst_line = input_file.readline()\nhow_many_lines = int(first_line.rstrip('\\n'))\n\nfor i in range(how_many_lines):\n    input_line = input_file.readline()\n    print(input_line.rstrip('\\n'))\n\ninput_file.close()\n\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nThe overall scheme for this is probably obvious by now. In the first half, when we’re writing the file, we write a “5” on its own line, and then write five more lines. In the second part, we 1. Read the first line. 2. rstrip() to get rid of the trailing newline 3. Use the results of that as the argument to int(), converting that string (“5”) to an actual integer (5). 4. and finally go through a for loop that many times just like before\nMost of the time we won’t have the luxury of knowing how many lines are in a file, though. We need a way to read all of the lines, line by line, without limit. For that, we can loop through the file and quit when Python returns an empty string with not even a newline character.\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\n\nline = input_file.readline()\nwhile line != '':\n    print(line.rstrip('\\n'))\n    line = input_file.readline()\ninput_file.close()\n\n5\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nThe while loop behaved just like we expected - strat by reading a line, and then every time the line isn’t empty, print it out and read another line. When you finally hit a line that is completely empty, exit the while loop and close the file.\nLooping through a file all the way to the end is such a common thing to do, Python has a shortcut for doing it. Remember when we talked about a for loop iterating over an ordered set? A file can be thought of as an ordered set of strings. They’re not in alphabetical order, but rather they are ordered by line number. That means we can:\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\n\nfor line in input_file:\n    print(line.rstrip('\\n'))\n\ninput_file.close()\n\n5\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nAs you can imagine, reading isn’t the only file operation you can do with a loop. You can also write to a file that way. For instance,\n\nmy_file_object = open(\"/tmp/five-liner.txt\", \"w\")\nfor i in range(7):\n    output_string = str(i)\n    my_file_object.write(output_string + '\\n')\nmy_file_object.close()\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\nfor line in input_file:\n    print(line.rstrip('\\n'))\ninput_file.close()\n\n0\n1\n2\n3\n4\n5\n6\n\n\nFinally, we don’t have to erase the contents of a file every time we write to it. It’s perfectly normal to append to an existing file, and for that the “a” mode can be used with open().\n\nmy_file_object = open(\"/tmp/five-liner.txt\", \"a\")\nfor i in range(7,10):\n    output_string = str(i)\n    my_file_object.write(output_string + '\\n')\nmy_file_object.close()\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\nfor line in input_file:\n    print(line.rstrip('\\n'))\ninput_file.close()\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nWhen you use the append mode, the write() calls will either add to the existing file or, if it doesn’t already exist, it will be created and then written to as though we used the “w” mode.\nSo far in this lesson we’ve acted like everything just works perfectly every time. In reality, it’s not that neat. Filenames get typed in wrong, didks get full, and lines that are supposed to be numbers might contain text instead. Any of these problems is enough to bring our Python code to a grinding halt. Our next lesson is all about how to handle these problems and many, many more like them. We’re going to learn about Exceptions!"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-09Strings.out.html",
    "href": "preliminaries/PRE100/PE100-09Strings.out.html",
    "title": "PE100-09: Strings",
    "section": "",
    "text": "We’ve been using strings in each of the previous modules, but we’ve accepted them as a found artifact without really getting into them and seeing how they. This module will correct that deficiency and make all of better peopleprogrammers.\n\nReview time\nLet’s take a quick look at what we’ve done so far.\nString literals:   \"Doug McKenzie\"\nString variables:  comedic_genius = \"Mel Brooks\"\n\nComparison:        if my_name == your_name:\n                   if your_name != \"Chuck Woolery\":\nConcatenation:     full_name = first_name+last_name\nRepetition:        \"ABC\" * 20\nThere is a lot more we can do with strings. We can: * Index into them * Iterate over them * Slice them * Search them * Call methods that act on them…\nIn fact, when you look at what you can do with a string and how you do it, you suddenly realize that a string is just (conceptually) a tuple of letters.\nWe can index into a string:\n\nmy_name=\"John Belushi\"\nprint(my_name[0])\nprint(my_name[len(my_name)-1])\nprint(my_name[-1])\n\nJ\ni\ni\n\n\nStrings are iterables:\n\nfor char in my_name:\n    print(char)\n\nJ\no\nh\nn\n \nB\ne\nl\nu\ns\nh\ni\n\n\nJust like a tuple, the elements of a string are immutable. Once a string is created, the characters can’t be changed.\n\nmy_name=\"Bob\"\nmy_name[0]='R'\n\nWe can slice strings:\n\nmy_name=\"Michael Jordan\"\nprint(my_name[2:4])\nprint(my_name[4:])\nprint(my_name[:2])\n\nch\nael Jordan\nMi\n\n\nWe can search into a string with the in operator:\n\ntweet_msg = \"I think synchrotrons are cool.\"\nif \"synchrotrons\" in tweet_msg:\n    print(\"found one!\")\n\nfound one!\n\n\nThere are a huge variety of string methods. We’ll look at just a few here. Some of them are handy for validating inputs…\n\nbolts = input(\"How many bolts did you install?\")\nif not bolts.isdigit():\n    print(\"I was expecting something that looked like an integer\")\nelse:\n    fasteners = int(bolts)\n\nI was expecting something that looked like an integer"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "",
    "text": "Niklaus Wirth was one of the founding giants of Computer Science. He wrote an introductory textbook whose title neatly summed up the act and art of programming: Algorithms + Data Structures = Programs. Data Structures are how information is stored in a computer, and algorithms are the instructions the computer applies to transform that data.\nTo run the code in a cell, first click in the cell to select it. Then you can either: 1. Go to the “Run” menu and choose “Run Selected Cells”, or 1. Just press Shift + Enter.\nLet’s do this now: click just below where it says “print (403.616”), then Go to the “Run” menu and choose “Run Selected Cells”.\nprint (403.616)\n\n403.616\nWhen it ran, it printed “403.616” on a line by itself. That was the output from the print.\nClick in the next cell (where it says “103.5”) to select that cell. Then hold down the Shift key while you press Enter.\n103.5\nIn Python, and in Jupyter notebooks, if the last (or only!) line evaluates to some value then it will be printed out. That’s how “103.5” got printed - a literal number evaluates to that number when it’s run. A “literal number” means you look at it in your code and you literally see a number.\nTake a look at a string literal. Run each of the next two cells…\nprint (\"the quick brown fox\")\nprint ('jumped over the lazy dogs')\nAt this point, we can use Python and Jupyter Lab as a scientific calculator. We have some literals of different types (int, real, and string, so far) and we can print them out with the print() function. If we don’t explicitly print anything at the end of a cell, Python will show us the last value that was computed."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#operators",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#operators",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Operators",
    "text": "Operators\nLike any programming language, Python lets you “do math” and lots of other things. Let’s take a look at some of the basic “operators”. In all of the code-containing cells through this course, try to predict what will happen first, and then run the code.\n\n2+2\n\n\n2*8\n\n\n6-4\n\n2\n\n\n\n7*6\n\n\n16/3\n\nBesides the “classic” operators, there are some handy extras:\n\n16//3\n\nWhat happened there? The // operator does integer division - it returns the whole number part of the answer, just like when we learned division in elementary school.\n\n16%3\n\nThe % operator returns the remainder. This is also called “modulo”, and the above would be pronounced “sixteen mod 3”.\n\n2**8\n\n256\n\n\n\n4**2.718281828459045\n\nThe ** operator does exponentiation. The arguments can be integers or they can be real numbers. Naturally, operators can be combined into arbitrarily long expressions.\n\n3*4*5\n\n\n6+4*5\n\nNotice what happens when we use different operators. They are applied in the “My Dear Aunt Sally” order of precendence (multiplication, division, addition, subtraction).\nOrder of operations: * Exponentiation: ** * Multiplication, Division, Remainder: * / // % * Addition and Subtraction: + -\nWithin the same level, operators are applied left-to-right. 8-5+2 is evaluated as 3+2 and yields 5. The exception is exponentiation: 2 ** 3 ** 4 is treated as 2 ** 81 and yeilds an annoyingly large number\n\nprint (2**3**4)\n\n\nprint (2**81)"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#variables",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#variables",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Variables",
    "text": "Variables\nUnless we just use Jupyter as a big, expensive scientific calculator, we need a way to store data. Variables were invented for just that purpose, and virtually every language has them. Think of them as a place to store data of some kind, and that place has a name. They behave in Python just like you’d expect.\n\nanswer = 42\nprint(answer)\n\n42\n\n\nWe just created a variable named answer and gave it the value 42. Variables are long-lived - later we’ll talk about just how long when we start writing our own functions, but until then our variables last as long as Python (or in our case, Jupyter) is running. Take a look - answer is still there.\n\nprint(answer)\n\nThe value stored in a variable can change. It can even change type:\n\nweight = 60\nweight = 70\nprint(weight)\nweight = \"not very much.\"\nprint(weight)\n\nWe can declare many variables, and we can “do things” with them just like we can when we type in numbers or strings.\n\nvolts = 120\namps = 4\nwatts = volts * amps\nwatts\n\nIn the last line, we just put watts because Jupyter automatically prints what the last line evaluates to.\nWe can use variables to change the order of operations. Let’s see the average price of two people’s meals:\n\ntotal = 22.41 + 19.45\naverage = total / 2\naverage\n\nThat’s the right answer. If we hadn’t done that, we would have gotten\n\n22.41 + 19.45 / 2\n\nwhich is utterly wrong. Beware of the order of operations… it is a frequent source of bugs in scientific programming.\n\nVariable Naming Rules\nFor the most part, you can pick whatever name makes sense for a variable, but there are some rules. When choosing a name: 1. No keywords (False won’t work.) 1. No spaces (sample thickness is invalid) 1. The first character must be one of * a-z, or A-Z, or _. (the underscore character) * As a result, no numbers (3rd_sample_holder is invalid) 1. After the first character, you can then have numbers (sample_holder_3 is perfectly valid) 1. No other symbols are allowed (exploded&destroyed_spectrometers is invalid, and probably suggests it’s time to review lab safety procedures).\nNote: Uppercase vs. Lowercase matters! Bevatron is not the same variable as bevatron"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#types",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#types",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Types",
    "text": "Types\nWe’ve hinted that variables have a “type”, and that the type can change if it needs to. The way it works is that variables keep track of what type they are (integer, real number, or string) and what their “value” is. We can even interrogate a variable as see what type it is:\n\nreading=7.2\nprint(\"reading:\")\nprint(type(reading))\nreading=\"rainbow\" # changes type of reading to string\nprint(type(reading))\n\nreading:\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n\n\n\nmy_number = 42\nmy_string = \"was that really the right answer?\"\n\nfirst_type = type(my_number)\nsecond_type = type(my_string)\nprint(first_type, second_type)\n\nThe type of a variable matters. Let’s create a variable with an integer in it and another with a string. Then let’s do some math:\n\nfirst_thing = 6\nsecond_thing = \"7\"\n\nprint (first_thing + second_thing)\n\nHow do we handle situations like that, where second_thing held a string representing a seven, but because it was a string variable it couldn’t be used as an integer? Python provides a few functions to convert values from one type to another. The str() function takes a variable and converts it to a string. The float() and int() functions convert their arguments to floating-point and to integer numbers, respectively.\n\nprint(first_thing + int(second_thing))\nprint(first_thing + float(second_thing))\n\n13\n13.0\n\n\nBeing able to convert values from one type to another is often called type coercion. These conversions are extremely important for situation where you need to get input from a user, even more so if you need to do it repetitively."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#continuation-character",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#continuation-character",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Continuation Character",
    "text": "Continuation Character\nSometimes the expressions we need to evaluate can be very long. It would be nice if we could split up a long expression and spread it out over a few lines. As a small example, we’ll take a look at 4+2+3. Many programming languages will let us split an expression anywhere we want, such as:\n\n4+2\n+3\n\n…but that result isn’t right in Python. The last line, +3, was evaluated and printed as the result of running that cell. In Python,it turns out, if we need to continue an expression on the next line we must end the current line with a backslash \\ and press enter. It has to be a backslash, by the way, and cannot be the forward slash like we use for division.\n\n4+2\\\n+3\n\n9\n\n\nTime for an exercise! Try to predict what will be printed when you run the next cell. Then, run the next cell and see how you did. If you miss one, make sure you figure out what happened before you go. I know, we’re professionals, I shouldn’t have to say that…\n\nprint(1 + 3 + 5 * 4 / 2)\nprint(7 % 2 * 10)\nbig_num = 1 + 2 + 3 + 4 \\\n     + 5 + 6\nprint(big_num)\n\nNow write an expression to average three numbers (12, 14, and 66), divide the result by three, and square it. You can use the code cell right below here:"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#the-string-type",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#the-string-type",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "The String Type",
    "text": "The String Type\nAt the beginning of this notebook, we casually mentioned “strings” without saying what they are. They’re just “sequences of characters”. And these can be any kind of characters - the English alphabet, the Hungarian alphabet, hiragana… it doesn’t matter.\n\nprint(\"I'll see you mañana, assuming I don't get irradiated to death.\")\n\nSome, probably most, languages contain strings inside “double quotes”, \", which is shift+apostrophe on US English keyboards. Other languages (SQL and Pascal are the only two I can think of) use single quotes: '. Python lets you use either one. You do have to be consistent in each string, but it can vary from one string to the next:\n\nprint(\"double quotes work\")\nprint('single quotes also work')\nprint('but do not try to mix the two in one string!\"\n\nBecause we can use either type of quotation mark, we can exploit that to let us put quotation marks into strings:\n\nprint(\"Don't put explosive mixtures in the spectrometer, please.\")\nprint('Of course he was warned... \"Do not turn the spectrometer into a bomb, please\" but I am sure he ignored that.')\n\nDon't put explosive mixtures in the spectrometer, please.\nOf course he was warned... \"Do not turn the spectrometer into a bomb, please\" but I am sure he ignored that.\n\n\nThat lets us embed whichever kind of quotation mark we need into a string.\nBut what if we need to embed both kinds of quotes into one string? We’re in luck: we can use the backslash character again to “quote” our quotation mark. In fact, we can quote any character with it if we need to.\n\nprint(\"We told him \\\"Hexanitrohexaazaisowurtzitane and spectrometers don't mix, buddy\\\", but we're pretty sure he ignored us.\")\n\nWe told him \"Hexanitrohexaazaisowurtzitane and spectrometers don't mix, buddy\", but we're pretty sure he ignored us.\n\n\nThat sentence contains three things, inside the string itself: 1. Double Quotes to surround a direct quotation 2. A single quote, also called an apostrophe depending on how it’s used, to make a contraction, and 3. A totally awesome/terrifying molecule you have to google to believe.\nOK, I’ll save you the trouble. Prepare to lose most of a day’s productivity. You’re welcome.\n(Derek has written gobs of articles on fun substances. Here are some more. )\nThere is one last kind of string literal. Sometimes you need a string that is several lines long. The “triple quote” is a way to do it. You have to use three double-quotes in a row:\n\ngigantic = \"\"\"This is the first line,\nThis is the second,\nand this is the third and final line of my string.\"\"\"\nprint(gigantic)\n\nTriple quotes are also an easier way to embed mixed kinds of quotation marks into strings:\n\nmovie_opinion = \"\"\"I know people who say \"The Avengers\" isn’t a good movie, but I don’t agree.\"\"\"\nprint(movie_opinion)\n\nI know people who say \"The Avengers\" isn’t a good movie, but I don’t agree."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#coming-up-next",
    "href": "preliminaries/PRE100/PE100-02TypesVarsAndOperators.out.html#coming-up-next",
    "title": "PE100-02: Types, Variables, and Operators",
    "section": "Coming Up Next",
    "text": "Coming Up Next\nWe just looked at enough of Python and Jupyter notebooks to use it as a basic calculator, but so far we can’t do any real, general-purpose programming with it. The “flow of control” sob far as been a straight line from top to bottom and we can’t change what we’re doing in response to different inputs. That’s about to change. In the next section we’ll look at the if statement and how to use it."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-07Exceptions.html",
    "href": "preliminaries/PRE100/PE100-07Exceptions.html",
    "title": "PE100-06: Exceptions",
    "section": "",
    "text": "Most of the time, the code we write does exactly what we expect. Our numbers are added up, files are written and read, and users type their input in neat little boxes. Sometimes, though, something goes wrong. Maybe the disk storage space filled up, or we try to write to a file in a directory we don’t have access to (or maybe the directory doesn’t even exist). When things like this happen, the Python interpreter stops the normal flow of execution.\nTake a look at an exception:\n\nfunny_number = 1/0\n\n\n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 funny_number = 1/0\n\nZeroDivisionError: division by zero\n\n\n\nWhen you run the above, Python will notice the error, stop the code from running, and point out that a “ZeroDivisionError” has occurred. Since this kind of thing wasn’t supposed to happen (division by zero is considered a Bad Thing(tm) by most people) we can say the situation we’re faced with is an exception. And indeed, Python’s error handling mechanisms are based on what are called “exceptions”.\nWhen Python saw the “division by zero” error, it stopped running the rest of the code. It created one of these Exceptions, and then it threw it. Nothing in our one-line example tried to do anything about that exception, so Python just let the program crash and it printed the helpful error messages for us.\nMost of the time, we want our code to be able to handle exceptions when they arrise. We want something that can catch these exceptions when they’re thrown. For that, we need to use Python’s try statement.\n\nTry, try again\n\ntry is how we safely wrap up a bit of code so that if something in there fails and an exception is thrown, we have a way to catch it. For example:\n\ntry:\n    denominator = int(input('Please enter the denominator'))\n    funny_number = 1000/denominator\n    print('the result was', funny_number)\nexcept ZeroDivisionError:\n    print('Looks like someone tried to divide by zero.')\nprint(\"Either we were able to do the division or else we successfully handled an exception.\")\n\n    \n\nPlease enter the denominator 0\n\n\nLooks like someone tried to divide by zero.\nEither we were able to do the division or else we successfully handled an exception.\n\n\nTry running the code above a few times. In the input area, try some different numbers each time. Maybe 4, 0, and -2. Notice that division by non-zero numbers works as expected. Notice also that division by zero now lets us print out an error message instead of crashing. Once we’re done handling the exception, the program resumes with the first line after the try/except structure.\nIn fact, there might be several except clauses if there are several kinds of exceptions that might be thrown. For example, let’s figure out how to share a pizza.\n\ntry:\n    people = int(input('How many people:'))\n    slices = 8/people\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nexcept ValueError:\n    print(\"The number of people must be a valid integer.\")\nexcept ZeroDivisionError:\n    print(\"Seriously? There are zero people sharing a pizza?\")\n\nprint(\"Whatever happened up there, this is the first line of code after\")\nprint(\"the try/except structure.\")\n\nHow many people: 0\n\n\nSeriously? There are zero people sharing a pizza?\nWhatever happened up there, this is the first line of code after\nthe try/except structure.\n\n\nAs you try different numbers of people, you can see that division by zero is, of course, handled. You can also enter things that aren’t integers. In response to the prompt, you could enter “Fred”. That can’t be converted to an integer, so the int() function throws an error. The except ValueError clause catches that exception and prints out a message.\nNotice that after either exception handler executes its code, the flow of control goes down to the next line after the try/except structure. In this case, that line is one that prints out a message saying it’s the first line of code after the try and all of the excepts.\nSometimes it’s hard to predict what exception might be thrown in a section of code. In that case, we can use just except: without any exception type. This serves as a “catch-all” handler.\n\ntry:\n    my_file = open('/tmp/ThisFileIsUnlikelyToExist', 'r')\n    people = int(input('How many people:'))\n    slices = 8/people\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nexcept ValueError:\n    print(\"The number of people must be a valid integer.\")\nexcept ZeroDivisionError:\n    print(\"Seriously? There are zero people sharing a pizza?\")\nexcept:\n    print(\"The catch-all handler has been awoken from its slumber.\")\n    print(\"I don't know what went wrong, except I can tell you it\")\n    print(\"wasn't a ValueError or a ZeroDivisionError, because\")\n    print(\"those would have been caught by more specific handlers\")\n    print(\"further up the list.\")\n\nThe catch-all handler has been awoken from its slumber.\nI don't know what went wrong, except I can tell you it\nwasn't a ValueError or a ZeroDivisionError, because\nthose would have been caught by more specific handlers\nfurther up the list.\n\n\nIndeed, if we’re lazy (or in a hurry) then we can get by with just a plain except clause and let the user figure it out later:\n\ntry:\n    my_file = open('/tmp/ThisFileIsUnlikelyToExist', 'r')\n    people = int(input('How many people:'))\n    slices = 8/people\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nexcept:\n    print(\"There was some sort of problem. I have no idea what.\")\n\nThere was some sort of problem. I have no idea what.\n\n\nUsing just a plain catch-all exception handler doesn’t give you much to work with, but it is slightly better than nothing. Your code won’t crash outright but you won’t much information about what went wrong. If only there was a way to examine that exception, to peer in and divine its secret nature…\nYep. Here you go…\n\ntry:\n    my_file = open('/tmp/ThisFileIsUnlikelyToExist', 'r')\n    people = int(input('How many people:'))\n    slices = 8/people\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nexcept Exception as err:\n    print(\"Error:\", err)\n\nError: [Errno 2] No such file or directory: '/tmp/ThisFileIsUnlikelyToExist'\n\n\nWhat we’ve done is catch any kind of exception (except Exception) and assigned it to a variable named “err”. Then we can print out err. We could even convert err to a string and search for the interesting parts (like the filename of our missing file) and do some clever error handling based on what specifically went wrong.\nPython has a few more tricks when it comes to exception handling, and these can be handy for making your code more readable.\n\n\nFancy exception handling\n\nA try/except structure can have an else clause. This clause will only be executed if no exception was thrown.\n\ntry:\n    people = int(input('How many people:'))\n    slices = 8/people\nexcept Exception as err:\n    print(\"Error:\", err)\nelse:\n    print('Each gets', format(slices, '.2f'), 'pieces.')\n\nHow many people: 0\n\n\nError: division by zero\n\n\nIf the user enters something that can be converted to an integer and is non-zero, then the program continues, finishing up the try block and executing the else block. On the other hand, if an exception of any type is thrown then the “number of pieces” message will never be printed.\nThere is also a finally clause. This one will run after everything else has happened, no matter what.\n\ntry:\n    output_file = open(\"/tmp/output\", \"w\")\n    people = int(input('How many people:'))\n    slices = 8/people\nexcept Exception as err:\n    print(\"Error:\", err)\nelse:\n    print('Each gets', format(slices, '.2f'), 'pieces.')\nfinally:\n    output_file.close()\n\nHow many people: 0\n\n\nError: division by zero\n\n\nIn the try clause, a file opening was added. In the finally clause, the file will be closed whether an exception was thrown or not.\nHow useful are else and finally clauses? It’s true they’re not absolutely necessary. Most programming languages don’t have anything like that. You can always juggle your code around and get by with just try and except. On the other hand, these two clauses can make your code easier to read and understand. Your precise intention can be discerned.\nWe’ve seen how to write Python code that catches errors without crashing. This technique works in both regular Python programs and in Jupyter Notebooks. Next up, we’ll turn back to ways of storing information. This time we’ll look at lists."
  },
  {
    "objectID": "preliminaries/PRE100/PE100-06Files.out.html",
    "href": "preliminaries/PRE100/PE100-06Files.out.html",
    "title": "PE100-05: Files",
    "section": "",
    "text": "You can write a good deal of software that runs entirely inside Jupyter notebooks or that runs on the command line and only communicates through the screen and the keyboard. Sometimes, though, you have to do with files. It may not be practical to hardcode all your data into assignment statements in Python, or maybe you have to deal with a number of files and therefore you can’t use pipes. link to Sys Fundamentals page here\nWe’ve already seen two basic ways to do Input and Output (often referred to as “I/O”). We’ve used input() to read from the keyboard and print() to send output to the screen. Those functions work quite well, except you might have to do a lot of typing or deal with your output scrolling off the screen. In neither case is the data durable - it goes away as soon as the program is done or you close the Jupyter notebook.\nThe input() and print() functions are just the tip of the proverbial iceberg in terms of getting information in and out of running Python code. Some of our other options include: * GUI controls: text box, menu, dialog box… * Networks: HTTP, TCP/IP sockets, Infiniband… * Databases: Relational (SQL) and NoSQL * Other: cameras, microphones, speakers, LabView"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-06Files.out.html#files",
    "href": "preliminaries/PRE100/PE100-06Files.out.html#files",
    "title": "PE100-05: Files",
    "section": "Files",
    "text": "Files\nPractically everyone is more-or-less familiar with the idea of a file, even if fairly few people know how they work. We’re going to ignore a lot of details for the moment and say this: a file is a long-lasting collection of bytes. It has a first byte, a last byte, and every one in between stays in the same order.\nThis begs the question “What is a byte?” A byte is just a small number from 0 to 255 (inclusive). We can assign meaning to those numbers, and if we’re smart about how we do it then we can represent any information a computer can process as long as we use enough of these bytes.\nWe like to think of files as being one of two types: binary files and text files. Binary files are pure data. We decide how to write bytes to a file to represent data. Then when we’re ready to read it in again, we read the bytes, process them somehow, and reconstruct the original data. It’s a great technique - it’s fast and efficient.\nWe won’t be talking about binary files in this notebook or even in this module. Fifteen years ago we wouldn’t have had a choice, we would have had to. These days, it’s unusual to have to deal with binary files, especially in Python, because there is so often a library function already available to do the work for us.\nText files, on the other hand, are probably something you’re already familar with - they are what you get when you edit a “plain text” file in “notepad” or “textedit”. In a text file, every one of the letter, number, and punctuation mark characters is assigned its own number. For instance, capital “A” is 65. “B” is 66. Not that it should ever matter, but here’s a complete list and then some!\nLet’s say you open an editor and type “CAT”. When you save that to a file, there will be a file that is three bytes long and contains the three bytes 67, 65, and 84. Actually there will usually be a fourth byte, 10, which is the character you get when you press “Enter” or “Return”.\nFor now, at least for a few minutes, we’re going to pretend the only language on earth is English. We’ll talk about other languages when we talk about networks.\nIt’s about time for an example, don’t you think?\n\nmy_file_object = open(\"/tmp/first_file.txt\", \"w\")\nmy_file_object.write(\"First Post!\")\nmy_file_object.close()\n\nThree lines of code was all it took to create a file, write to it, and tidy up after ourselves. What does each of those lines do?\nmy_file_object = open(\"/tmp/first_file.txt\", \"w\")\nmy_file_object is an object variable. Think of an object as a way to store data in a variable along with some functions that only make sense to that data. They hide a lot of complexity from us. A file object is one that keeps track of a filename, how to get to it, and how to use it. It has some functions built in to it to help us do things to the file.\nPython gives us the function “open”. It gets a file ready to be used by our code. It takes two arguments. The first is the file’s name, and the second is the mode we want to use the file in. In our example, we specified that the file’s name was “first_file.txt” and that it was in the “/tmp” directory. Then in the second argument we specified “w”, meaning we wanted to write to the file. The “w” mode will cause the file to be created if it didn’t already exist. If it did already exist, on the other hand, all the contents of it will be deleted and we’ll start writing from the beginning just as if the file was created from scratch. We’ll see more modes as we go.\nmy_file_object.write(\"First Post!\")\nThis line uses one of those functions that are tucked away inside an object. In this case, we’re calling the file object’s “write” function. It does what we expect - it takes its argument, in this case “First Post!”, and causes it to be written to disk byte by byte.\nmy_file_object.close()\nFinally, we call one more of the file object’s functions: close. When we run this, Python tells the operating system “Hey, we’re done with the file. You can get rid of any of the tedious housekeeping data that operating systems keep behind the scenes!”\nClosing files is considered “good programming hygene”. You’re allowed 1024 file objects to be open and connected to files in one program on the CLASSE cluster of computers. I’ll say from my experience: if you think you need that many, you’re probably doing something the wrong way.\nWriting files, then, is fairly easy. What about reading files? I’m glad you asked.\n\ninput_file = open(\"/tmp/first_file.txt\",\"r\")\nthe_contents = input_file.read()\ninput_file.close()\n\nthe_contents\n\n'First Post!'\n\n\nYou can probably tell mostly how that worked just by looking at. We used the open() function again, but this time with a “r” for our mode. This means “read”. Also, this time we used read() instead of write(). The read() function reads in an entire file and saves it a string variable. Finally, we call close() again to close the file and tidy up after ourselves.\nNote that if the file is, say, 500 megabytes long, the string variable is going to be very, very large - roughly half a gigabyte. Python can handle this, but it may not be terribly convenient. If the file is more than 100-200 gigabytes, the CLASSE servers are probably not going to be able to handle. I say “probably” because there are a lot of factors at play.\nJust writing one line to a file is probably not very useful. Let’s try writing two lines:\n\nmy_file_object = open(\"/tmp/first_file.txt\", \"w\")\nmy_file_object.write(\"First line written.\")\nmy_file_object.write(\"This is my second line.\")\nmy_file_object.close()\n\nWhen we run that, it will open /tmp/first_file.txt for writing and it will delete anything already in it (that’s what the “w” means, remember?). Then it will write “First line written.” and “This is my second line.”.\nLet’s read the file again and prove to ourselves that it worked…\n\ninput_file = open(\"/tmp/first_file.txt\",\"r\")\nthe_contents = input_file.read()\ninput_file.close()\n\nthe_contents\n\n'First line written.This is my second line.'\n\n\nOh no! The two lines ran together!\nAnd that is one of the first differences we’ll see between write() and print(). Print() always adds a newline character after it prints out anything. Remember when I said there would usually be a byte at the end of a line, represented by the number 10? This character is called “newline” and it, as the name implies, marks where a new line starts.\nIn all likelihood, when we do two write() statements like we did, we want to put a newline character in the file to make it into two lines. Fortunately, there are several ways to do that. Here are two of them.\nThe first way is simple and direct - call write() three times instead of two and put a newline in there “by hand”, as it were:\n\nmy_file_object = open(\"/tmp/first_file.txt\", \"w\")\nmy_file_object.write(\"First line written.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"This is my second line.\")\nmy_file_object.close()\n\ninput_file = open(\"/tmp/first_file.txt\",\"r\")\nthe_contents = input_file.read()\ninput_file.close()\n\nthe_contents\n\n\n\n'First line written.\\nThis is my second line.'\n\n\nThe output looks a little strange. We put an extra write() function call, but we gave it an odd looking argument - . That is a backslash (usually between the Enter and the backspace keys on a US keyboard) immediately followed by a lowercase “n”. The combination together means “newline character”. This much is fairly straightforward.\nNext we read the contents of the file. This is just like before.\nFinally, and this is where things take an unexpected turn, we evaluate the_contents and let Jupyter print that out for us. And when Jupyter does that, we see the “” there. It seems like Python didn’t convert those two characters to a newline, just sticking them in there as-is, and still left us with one long line. But is that true? Has Python foresaken us?\nRun the code in the next cell:\n\nprint(the_contents)\n\nFirst line written.\nThis is my second line.\n\n\nSalvation! print() did the right thing. This is a key difference between just typing a variable or an expression at the end of a cell and letting Python evaluate it versus putting a print() in there and having absolute control over what gets sent to the notebook and on to the screen.\nThis also illustrates something else important and useful: all of the code cells in this notebook are being run by the same Python “interpreter”. This means if we set a variable to a value in one cell, we will see the same value stored in that variable in other cells. That’s how we were able to print what was stored in the_contents in the cell above even though we had set its value to the file contents two cells above that.\nIf a file only has a line or two, it’s not a big deal dealing with that with string functions. If a file has millions of lines, then it becomes a bit of a hassle. We need a way to read a file one line at a time. Fortunately, there’s readline():\n\ninput_file = open(\"/tmp/first_file.txt\",\"r\")\nline_one = input_file.readline()\nline_two = input_file.readline()\ninput_file.close()\n\nprint(line_one)\nprint(line_two)\n\nFirst line written.\n\nThis is my second line.\n\n\nThis does almost what we expect: it reads both lines from the file, one at a time, and prints them out. The only snag is that blank space between the lines. What has happened? It turns out readline() reads the entire line, even the newline character at the end. We can see this if we evaluate the string instead of just printing it:\n\nline_one\n\n'First line written.\\n'\n\n\nThere’s that \\n again! What about the second line?\n\nline_two\n\n'This is my second line.'\n\n\nWhen readline() reads a line, it includes the newline character at the end unless it reaches the end of the file and the file didn’t end with a newline.\nIt’s rare that we would want to read a bunch of lines in a file with the newlines included. That’s just not something we do very often, and practically never in scientific software. We’ll almost always want to trim off the newline character. And for that, we have the rstrip() function. It takes a string, strips off any newlines on the right side of it, and returns that cleaned-up string. rstrip() does that for the right side of the string, lstrip() cleans up the left side (the beginning of the string) and strip() goes crazy and does both ends at the same time.\nLet’s try it:\n\nclean_first_line = line_one.rstrip('\\n')\nclean_second_line = line_two.rstrip('\\n')\n\nprint(clean_first_line)\nprint(clean_second_line)\n\nFirst line written.\nThis is my second line.\n\n\nWhat’s going on here? A couple of things. The first thing to note is that rstrip() and its close companions lstrip() and strip() take one argument, which is the character to be stripped. Practically always we’ll want to get rid of the trailing newline character.\nThe other interesting things is how we called the rstrip() function in the first place. We gave the name of the string variable, a period, and the name of the function we were calling. This is just like how we called the close() function on a file object. And in fact, strings are another kind of object in Python. We’ll see a lot more on this later.\nHistorical note: The original programming language that had objects was named “Smalltalk”. In Smalltalk, the functions that were inside of objects were called “methods”. You’ll still hear people call them that. Later, the “C++” language came along and it called methods “member functions”. When programmers talk about the functions that are contained in objects, we’ll use either term interchangably, sometimes even switching in the middle of a sentence. We now return to your Python tutorial, already in progress…\nWe read both lines in the file we created. We were able to call readline() twice and know that we had all of our lines in the file because (1) we created the file ourselves and (2) we therefore knew it had precisely two lines. It wasn’t even too bad having to type those readline() and rstrip() lines twice. But what if we had a lot more lines? We would certainly want to use a loop.\nFor example, what do we do with a five-line file?\n\nmy_file_object = open(\"/tmp/five-liner.txt\", \"w\")\nmy_file_object.write(\"Line 1.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 2.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 3.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 4.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 5.\")\nmy_file_object.write('\\n')\nmy_file_object.close()\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\nfor i in range(5):\n    input_line = input_file.readline()\n    print(input_line.rstrip('\\n'))\n\ninput_file.close()\n\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nNo problem - we just use a for loop and do the readline() inside of it. It repeats the five times we asked for. In this case, after we read each line we cleaned it up a little and printed it.\nBut what if we can’t know the number of lines ahead of time? One approach is to have whatever program that creates the file write the number of lines that will be in it first. I won’t say this is a common approach in scientific software, but it isn’t exactly rare either.\n\nmy_file_object = open(\"/tmp/five-liner.txt\", \"w\")\nmy_file_object.write(\"5\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 1.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 2.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 3.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 4.\")\nmy_file_object.write('\\n')\nmy_file_object.write(\"Line 5.\")\nmy_file_object.write('\\n')\nmy_file_object.close()\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\n\nfirst_line = input_file.readline()\nhow_many_lines = int(first_line.rstrip('\\n'))\n\nfor i in range(how_many_lines):\n    input_line = input_file.readline()\n    print(input_line.rstrip('\\n'))\n\ninput_file.close()\n\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nThe overall scheme for this is probably obvious by now. In the first half, when we’re writing the file, we write a “5” on its own line, and then write five more lines. In the second part, we 1. Read the first line. 2. rstrip() to get rid of the trailing newline 3. Use the results of that as the argument to int(), converting that string (“5”) to an actual integer (5). 4. and finally go through a for loop that many times just like before\nMost of the time we won’t have the luxury of knowing how many lines are in a file, though. We need a way to read all of the lines, line by line, without limit. For that, we can loop through the file and quit when Python returns an empty string with not even a newline character.\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\n\nline = input_file.readline()\nwhile line != '':\n    print(line.rstrip('\\n'))\n    line = input_file.readline()\ninput_file.close()\n\n5\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nThe while loop behaved just like we expected - strat by reading a line, and then every time the line isn’t empty, print it out and read another line. When you finally hit a line that is completely empty, exit the while loop and close the file.\nLooping through a file all the way to the end is such a common thing to do, Python has a shortcut for doing it. Remember when we talked about a for loop iterating over an ordered set? A file can be thought of as an ordered set of strings. They’re not in alphabetical order, but rather they are ordered by line number. That means we can:\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\n\nfor line in input_file:\n    print(line.rstrip('\\n'))\n\ninput_file.close()\n\n5\nLine 1.\nLine 2.\nLine 3.\nLine 4.\nLine 5.\n\n\nAs you can imagine, reading isn’t the only file operation you can do with a loop. You can also write to a file that way. For instance,\n\nmy_file_object = open(\"/tmp/five-liner.txt\", \"w\")\nfor i in range(7):\n    output_string = str(i)\n    my_file_object.write(output_string + '\\n')\nmy_file_object.close()\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\nfor line in input_file:\n    print(line.rstrip('\\n'))\ninput_file.close()\n\n0\n1\n2\n3\n4\n5\n6\n\n\nFinally, we don’t have to erase the contents of a file every time we write to it. It’s perfectly normal to append to an existing file, and for that the “a” mode can be used with open().\n\nmy_file_object = open(\"/tmp/five-liner.txt\", \"a\")\nfor i in range(7,10):\n    output_string = str(i)\n    my_file_object.write(output_string + '\\n')\nmy_file_object.close()\n\ninput_file = open(\"/tmp/five-liner.txt\",\"r\")\nfor line in input_file:\n    print(line.rstrip('\\n'))\ninput_file.close()\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nWhen you use the append mode, the write() calls will either add to the existing file or, if it doesn’t already exist, it will be created and then written to as though we used the “w” mode.\nSo far in this lesson we’ve acted like everything just works perfectly every time. In reality, it’s not that neat. Filenames get typed in wrong, didks get full, and lines that are supposed to be numbers might contain text instead. Any of these problems is enough to bring our Python code to a grinding halt. Our next lesson is all about how to handle these problems and many, many more like them. We’re going to learn about Exceptions!"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-09Strings.html",
    "href": "preliminaries/PRE100/PE100-09Strings.html",
    "title": "PE100-09: Strings",
    "section": "",
    "text": "We’ve been using strings in each of the previous modules, but we’ve accepted them as a found artifact without really getting into them and seeing how they. This module will correct that deficiency and make all of better peopleprogrammers.\n\nReview time\nLet’s take a quick look at what we’ve done so far.\nString literals:   \"Doug McKenzie\"\nString variables:  comedic_genius = \"Mel Brooks\"\n\nComparison:        if my_name == your_name:\n                   if your_name != \"Chuck Woolery\":\nConcatenation:     full_name = first_name+last_name\nRepetition:        \"ABC\" * 20\nThere is a lot more we can do with strings. We can: * Index into them * Iterate over them * Slice them * Search them * Call methods that act on them…\nIn fact, when you look at what you can do with a string and how you do it, you suddenly realize that a string is just (conceptually) a tuple of letters.\nWe can index into a string:\n\nmy_name=\"John Belushi\"\nprint(my_name[0])\nprint(my_name[len(my_name)-1])\nprint(my_name[-1])\n\nJ\ni\ni\n\n\nStrings are iterables:\n\nfor char in my_name:\n    print(char)\n\nJ\no\nh\nn\n \nB\ne\nl\nu\ns\nh\ni\n\n\nJust like a tuple, the elements of a string are immutable. Once a string is created, the characters can’t be changed.\n\nmy_name=\"Bob\"\nmy_name[0]='R'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[4], line 2\n      1 my_name=\"Bob\"\n----&gt; 2 my_name[0]='R'\n\nTypeError: 'str' object does not support item assignment\n\n\n\nWe can slice strings:\n\nmy_name=\"Michael Jordan\"\nprint(my_name[2:4])\nprint(my_name[4:])\nprint(my_name[:2])\n\nch\nael Jordan\nMi\n\n\nWe can search into a string with the in operator:\n\ntweet_msg = \"I think synchrotrons are cool.\"\nif \"synchrotrons\" in tweet_msg:\n    print(\"found one!\")\n\nfound one!\n\n\nThere are a huge variety of string methods. We’ll look at just a few here. Some of them are handy for validating inputs…\n\nbolts = input(\"How many bolts did you install?\")\nif not bolts.isdigit():\n    print(\"I was expecting something that looked like an integer\")\nelse:\n    fasteners = int(bolts)\n\nHow many bolts did you install? op\n\n\nI was expecting something that looked like an integer"
  },
  {
    "objectID": "preliminaries/PRE100/PE100-08Lists.html",
    "href": "preliminaries/PRE100/PE100-08Lists.html",
    "title": "PE100-08: Lists",
    "section": "",
    "text": "All of the variables we’ve seen so far store exactly one value. If you set the variable “weight” to 74.5, then 74.5 is the only value there is in “weight”. Nice and simple. If we need to save several values then we can use several variables…\n\nweight_1 = 74.5\nweight_2 = 76.7\nweight_3 = 77.1\n\nAs you can imagine, this turns tedious in a hurry. What if you had a thousand values to deal with? And even if you did all of that typing, doing any kind of non-trivial computation with it would be difficult, too. We need a way to store a bunch of values, but doing it in a way that makes it easy to manipulate the whole thing as a whole or each individual value. For doing that, Python provides us with lists.\nPython is one of the few languages that support lists deep down in the language itself. Because of that, they’re easy to work with. Let’s take a look, shall we?\n\nnames = ['Alice', 'Bob', 'Candice', 'Dan']\nnames\n\n['Alice', 'Bob', 'Candice', 'Dan']\n\n\nLists are represented with square brackets [ ] at the beginning and end, and with the values inside the brackets separated by commas.\n\nodd_numbers = [1, 3, 5, 7, 9]\ningredients = ['flour', 'lard', 'baking powder', 'milk']\n\nThe values in a list don’t all have to be the same type.\n\nplaying_card = [9, 'Diamonds']\n\nA list can have any number of values, limited only by the amount of memory in the computer that is hosting the Jupyter (or JupyterLab) server. Lists are even allowed to have no values in them.\n\nempty_list = []\n\nSo far we’ve been creating lists using literal values, but we could use variables just as easily…\n\nnimh = 16\nlithiumPrimary = 2\ncarbonZinc = 6\n\nbattery_inventory = [nimh, lithiumPrimary, carbonZinc]\nprint(battery_inventory)\n\n[16, 2, 6]\n\n\nTo find out how many elements are in a list, use the len() function:\n\nnumber_of_ingredients = len(ingredients)\nprint(number_of_ingredients)\n\nprint(len(battery_inventory))\n\n4\n3\n\n\nThere are operators that act on lists. The * operator is used for repetition…\n\nmy_list = [1, 2, 3] * 2\nprint(my_list)\nmany_zeros = [0] * 25\nprint(many_zeros)\n\n[1, 2, 3, 1, 2, 3]\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n\n…and the + operator combines two lists:\n\nbig_list = my_list + many_zeros\nprint(big_list)\n\n[1, 2, 3, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n\nLists are iterables, just like the results of the range() function, so they can be iterated over using a for loop:\n\nfor name in ['David', 'Bill', 'Richard']:\n    print(name)\n\nDavid\nBill\nRichard\n\n\n\nfor ingr in ingredients * 3:\n    print(ingr)\n\nflour\nlard\nbaking powder\nmilk\nflour\nlard\nbaking powder\nmilk\nflour\nlard\nbaking powder\nmilk\n\n\nIt’s fairly common to iterate over a list for things like sums and averages.\n\ntotal = 0\nfor item in [4, 3, 4, 5]:\n    total += item\nprint(total)\n\n16\n\n\nThe above code steps its way over all of the values in the list. Each time it goes to a new value, it adds that value to total. When it gets to the end, all of the values have been added up. If we want an average, we don’t have to count the values ourselves. We can just use the len() function.\n\ntotal = 0\nmy_list = [4, 3, 4, 5]\nfor item in my_list:\n    total += item\navg = total / len(my_list)\nprint(avg)\n\n4.0\n\n\nSometimes you need to use a particular value in a list and you don’t want to iterate over the whole thing. For this, Python gives us indexing, letting us directly access any element of a list. The first (as it appears on screen, “leftmost”) element in numbered zero and each one after that goes up by one. The highest numbered one is therefore the length of the list minus one.\n\nprint(ingredients)\nprint()\nprint(\"Of all the biscuit ingredients,\", ingredients[0] , \"is the most important one.\")\nprint(\"The second most important one is\", ingredients[2])\n\n['flour', 'lard', 'baking powder', 'milk']\n\nOf all the biscuit ingredients, flour is the most important one.\nThe second most important one is baking powder\n\n\nLike the majority of programming languages, Python uses square brackets to indicate the index into the list. Unlike the vast majority of languages, Python allows indexes to be negative! A negative number for an index means “count backwards from the end”. my_list[-1] refers to the item at the end of the list. my_list[-3] refers to the third to last item.\n\nprint(ingredients[-1])\nprint(ingredients[-3])\n\nmilk\nlard\n\n\nWe’ve seen how to iterate over lists and also how to access individual list elements by using indexing. Python has a special indexing scheme, though, that lets us deal with small lists made from our original list. This is called List Slicing and can save you a lot of work sometimes. The overall syntax for this looks like list_name[start:end]\nAn example is definitely called for here:\n\nmy_list = [2, 4, 6, 8, 10, 12]\nprint(my_list[1:3])\n\n[4, 6]\n\n\nRemember that list indexes count from zero, and remember also that ranges in Python include the starting index (here, it’s the 1) and will continue to the last value that is smaller than the one on the right side of the colon.\nBoth the starting and the ending indexes are optional! If one of the two is missing, it will be interpreted as 0 or the list’s length, respectively.\n\nprint(my_list)\nprint()\nprint(my_list[:3])\nprint(my_list[1:])\nprint(my_list[:])\n\n[2, 4, 6, 8, 10, 12]\n\n[2, 4, 6]\n[4, 6, 8, 10, 12]\n[2, 4, 6, 8, 10, 12]\n\n\nAnd finally, the in operator is used to test list membership.\n\nlucky_numbers = [2, 7, 17, 9]\nplayer_number = int(input('Enter your favorite number'))\nif player_number in lucky_numbers:\n    print(\"Your favorite number is lucky!\")\nelse:\n    print(\"Sorry! Better luck next time!\")\n\nEnter your favorite number 8\n\n\nSorry! Better luck next time!\n\n\n\nThere’s Method to the Madness\n\nThere are two kinds of functions available for working with lists. Built-in functions are the ones that are part of Python itself. Methods, as you’ll recall from the unit on files, are special functions that are situated inside of objects and only usable with that kind of object. Python lists are objects. They’re iterable objects, in fact.\nLet’s take a look at a few of the methods available for working with lists. First up is append().\n\nprint(lucky_numbers)\nlucky_numbers.append(106)\n\nlucky_numbers\n\n[2, 7, 17, 9]\n\n\n[2, 7, 17, 9, 106]\n\n\nJust as the name implies, append() adds an element to the end of a list.\nBut what if we want to put a new element in a specific place? For that, there is insert().\n\nprint(lucky_numbers)\nlucky_numbers.insert(2, 202)\nlucky_numbers\n\n[2, 7, 17, 9, 106]\n\n\n[2, 7, 202, 17, 9, 106]\n\n\nThe insert function takes two arguments. The first is the position in the list where the insertion should happen. In the example above, it was at position 2. Remember, list indexes start at zero! The second argument is the element to insert. And when we look at the resulting list, we see that 202 is in position 2 now (which is the third position!) and all the other elements have been shifted to the right.\nWe’ve been fetching elements from the list by location number, so far. How do we find something by searching for it? The index() method does that.\n\nwhere_found = lucky_numbers.index(202)\nprint(where_found)\n\n2\n\n\nWe passed the argument 202 to the index method. It searched the list and returned the index of the first occurence. That index is 2. Makes sense because we just inserted it there a minute ago!\nIf we can insert things into a list then surely we can remove them too, right? Indeed we can with the remove() method.\n\nprint(lucky_numbers)\nlucky_numbers.remove(7)\nprint(lucky_numbers)\n\n[2, 7, 202, 17, 9, 106]\n[2, 202, 17, 9, 106]\n\n\nWatch out! remove() looks up an item, like index() does, and then removes it. It doesn’t take a position number. In other words:\n\npeople = ['David', 'Bill', 'Richard']\npeople.remove('Bill')\nprint(people)\n\n['David', 'Richard']\n\n\nYou might find yourself needing to sort the items in a list, and for that the sort() method exists:\n\nprint(lucky_numbers)\nlucky_numbers.sort()\nprint(lucky_numbers)\n\n[2, 202, 17, 9, 106]\n[2, 9, 17, 106, 202]\n\n\nFinally, there are methods to find the greatest and smallest values in a list.\n\nprint(min(lucky_numbers))\nprint(max(lucky_numbers))\n\n2\n202\n\n\nEarlier we saw the use of len() to find out how many items are in a list. This is a built-in function and works on many types of variables, not just lists. There are two more built-in functions that are useful for working with lists: min() and max().\n\nsiblings = ['David', 'Bill', 'Shirley', 'Richard', 'Laverne']\nprint(min(siblings))\nprint(max(siblings))\n\nBill\nShirley\n\n\n\n\nLists and Functions\n\nFunctions have no problem accepting lists as arguments and they can also return lists as the function’s value. There is a subtle “gotcha” when passing lists as an argument, though.\nFirst, let’s look at a simple example:\n\noriginal_list = [1, 2, 3, 9]\n\ndef sum_of_list(list_to_sum):\n    sum = 0\n    for i in list_to_sum:\n        sum = sum + i\n    return sum\n\nthe_sum = sum_of_list(original_list)\nthe_sum\n\n15\n\n\nThat worked as expected - there’s no problem passing lists into functions. What about returning lists from functions?\n\ndef pet_factory(how_many_pairs):\n    pets = ['goldfish', 'catfish'] * how_many_pairs\n    return pets\n\nmany_fish = pet_factory(5)\nprint(many_fish)\n\n['goldfish', 'catfish', 'goldfish', 'catfish', 'goldfish', 'catfish', 'goldfish', 'catfish', 'goldfish', 'catfish']\n\n\nEarlier, when we talked about functions in section 5, we said that if a function changes the value of one of its arguments then the effects of that change stay inside the function and aren’t visible to anything when the function exits. That statement was mostly true. If you pass a list as an argument to a function and if that function changes the list then the change made there will be visible outside. Strings, floats, and integers asre protected, but lists are more exposed.\n\noriginal_list = [1, 2, 3, 9]\n\ndef doubler(numbers):\n    for i in range(len(numbers)):\n        numbers[i]=numbers[i]*2\n\nprint(original_list)\ndoubler(original_list)\nprint(original_list)\n\n[1, 2, 3, 9]\n[2, 4, 6, 18]\n\n\nChanging the value of an argument inside of a function usually isn’t a great idea, but in the case of lists it can be useful.\n\n\nNo Funny Glasses Required\n\nThe lists we have worked with up to this point have all been one dimensional. Lists get a lot more interesting as the number of dimensions goes up.\nUnlike most programming languages, Python does not have a multi-dimensional list or array construction, per se. What Python does have is a list that is versatile enough to contain anything - and that includes containing other lists! A two-dimensional list in Python is just a “list of lists”.\nTake a look:\n\nfirst_presidents = [['George', 'Washington'], ['John', 'Adams'], ['Thomas', 'Jefferson']]\n\nAbove, on that very long line, we’ve created a list with square brackets. Inside that list, we’ve put three more lists inside square brackets of their own. So we’ve made a list of lists.\nThat long line is hard to read, isn’t it? Python won’t let us just split a long line of code across multiple lines… unless we explicitly tell it what we’re doing. That is done by ending each line with a backslash and immediately pressing enter. It looks like this:\n\nfirst_presidents = [['George', 'Washington'],\\\n                    ['John', 'Adams'],\\\n                    ['Thomas', 'Jefferson']]\n\nJupyter even goes to the trouble to line up the columns for us.\nAnyway, let’s see what we’ve created.\n\nprint(first_presidents)\n\n[['George', 'Washington'], ['John', 'Adams'], ['Thomas', 'Jefferson']]\n\n\n\nprint(first_presidents[0])\n\n['George', 'Washington']\n\n\n\nprint(first_presidents[2])\n\n['Thomas', 'Jefferson']\n\n\nWe can index into the outer array, the one that contains the smaller lists, just like we normally would. We can also index into the inner array two different ways. The long way…\n\npresident_number_one = first_presidents[0]\nfirst_name = president_number_one[0]\nfirst_name\n\n'George'\n\n\n… or we can take the shortcut:\n\nfirst_name = first_presidents[0][0]\nfirst_name\n\n'George'\n\n\nThe first zero got us to the “George”, “Washington” element, and the second zero indexed into that and gave us ‘George’. Let’s try some other combinations:\n\nnext_first_name = first_presidents[1][0]\nnext_first_name\n\n'John'\n\n\n\nanother_name = first_presidents[1][1]\nanother_name\n\n'Adams'\n\n\nIt’s easy to see how we’re indexing into this two-dimensional list. In fact, it works roughly the same way as a 2-D array in most programming languages.\nIt’s so similar, in fact, that you’re probably feeling the urge to do some Linear Algebra right now.\nDon’t. Not yet.\nPython’s multidimensional list support is exactly that: support for lists. It can be pressed into service for arrays (in the linear algebraic sense of the term) but performance is pretty bad. In Programming Elements 101 we’ll see a software library called “numpy”. It is superior for arrays where you want to do some math.\nNow let’s look at how to traverse multi-dimensional array. We’ll create a 2-D list that look like this:\n        Column 0  Column 1  Column 2  Column3\nRow 0.     A         B         C         D\nRow 1.     E         F         G         H\nRow 2.     I         J         K         L\nRow 3.     M         N         O         P\n\nletter_table = [['A', 'B', 'C', 'D'],\\\n['E', 'F', 'G', 'H'],\\\n['I', 'J', 'K', 'L'],\\\n['M', 'N', 'O', 'P']]\n\nWe can get a whole row:\n\nprint(letter_table[1])\n\n['E', 'F', 'G', 'H']\n\n\nor we can get a specific cell (the order is row, then column):\n\nprint(letter_table[2][1])\n\nJ\n\n\nWe can access the table by column, but it’s not as easy. We’ll have to write a loop that steps down a column and reads the values:\n\nfor i in range(len(letter_table)):\n    print(letter_table[i][3])\n\nD\nH\nL\nP\n\n\nWhat if we want to access all of the cells in the array? For that, nested loops work.\n\nfor row in range(len(letter_table)):\n    for col in range(len(letter_table[row])):\n        print(letter_table[row][col])\n\nA\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\n\n\n“But wait!”, I hear you say. “I need to store higher-dimensionality data!” No problem. Python will allow arbitrarily deep nesting. We can have lists of lists of lists (3 dimensions) or lists of lists of lists of lists for four dimensions. Accessing the cells is just a matter of adding more array indexes to the end of the name.\n\nfirst_vice_presidents = [[\"John\", \"Adams\"],\\\n                         [\"Thomas\", \"Jefferson\"],\\\n                         [\"Aaron\", \"Burr\"]]\n\nearly_us_leaders = [first_presidents, first_vice_presidents]\nprint(early_us_leaders[1][0][1])\nprint(early_us_leaders[1][2][0])\n\nAdams\nAaron\n\n\nIt’s easy to get confused with deeply nested lists. Three dimensions isn’t bad, four is managable, but as the structures get deeper and deeper I have to resort to drawing pictures and frequent testing every step of the way.\ntl;dr: If you’re a string theorist working in 21 dimensions or whatever, Python lists probably aren’t the way to go. You should use numpy.\n\n\nTuples\n\nA “double”, mathematically speaking, is two of something. A “triple” is three of them. If you don’t know how many, or you don’t want to specify, then it’s generically called a “tuple” (pronounced “Too pull”, according the The American Heritage Dictionary and, more importantly, everyone who has ever taught the database class).\nPython gracious provides us with tuples. Their syntax is just like a list, only using parentheses instead of square brackets. For instance:\n\nmy_tuple = (2, 8, 256)\nprint(my_tuple[1])\n\n8\n\n\nTuples have some restrictions when compared to lists. * You can’t sort them. * You can’t insert or delete from them * You can’t change the values in them\nWhy would we want tuples if they’re so similar to lists, only somewhat disabled? In a word, “speed”. They’re very fast compared to lists. That’s why some Python functions require them. The most likely time you’ll see tuples is when you’re accessing data from a database. The second most common use is when you need to return multiple values from a function.\nSince tuples have the speed advantage but lists are more versatile, it’s not unusual to see programmers use the list() and tuple() functions to convert between the two types:\n\nmy_tuple = (2, 8, 256)\nlist_version = list(my_tuple)\nlist_version\n\n[2, 8, 256]\n\n\n\nmy_list=[2, 4, 6, 8]\ntuple_version = tuple(my_list)\ntuple_version\n\n(2, 4, 6, 8)\n\n\nReturning multiple values from a function feels like cheating the first time you do it. After all, sin(x) returns exactly one number, right?\nWhat if you wrote a function that returns a complex number, like 1.105+7.3i ? That’s one number (albeit one on the complex plane) but it’s written like two pieces of data being returned.\nWhat if you got really fancy and wrote a function that returned a column vector? That would be like returning a lot of numbers all at once, wouldn’t it?\nSo returning multiple values at once isn’t that bad, is it? Especially if the values all have related meaning and “belong” together.\n\ndef get_extremes(number_list):\n    min_val = min(number_list)\n    max_val = max(number_list)\n    return (min_val, max_val)\n\nnumbers = [5, 3, 2, 7, 2, 5]\nlow, high = get_extremes(numbers)\nprint(low)\nprint(high)\n\n2\n7\n\n\nA couple of things to note. First, notice how the function creates a tuple and returns it. The parentheses indicate a tuple is being constructed and the min_val and max_val variables are put into the tuple as the first and second elements.\nSecond, look at how that tuple is returned to the caller, taken apart, and stored in a pair of variables. You’ll see the syntax first_variable, second_variable, third_variable = func() when a tuple is returned from a function. The first element of the tuple is placed in first_variable and so on.\n\n\nComing Up Next\n\nWe’ve made it to the end of this section. Take a moment, breathe, and relax… this is the longest module in the “Python and Jupyter” series. Next up we have lots of information on strings. We’ve been using strings a lot already without really looking at what they are and what they can do. It’s time to remedy that.\n(pssst. Want a hint? Strings are just tuples of letters!)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About CITEAM",
    "section": "",
    "text": "The Cyberinfrastructure Training for Electron Microscopy–Enabled Materials Science (CITEAM) project brings together PIs with expertise in CI as well as in imaging-enabled materials science to develop an innovative training program targeting the materials science community that relies on advanced microscopes (e.g., Transmission Electron Microscopes (TEM)) for research.\nThe training program covers several relevant thematic areas – TEM instrument software, image analysis, scientific computing, application of AI in TEM image and data analysis, diffraction and spectroscopy data analysis, distributed computing for EM data processing, data curation and FAIR principles.\nCITEAM includes an additional element of “training the trainers” by exposing the relevant CI contributors – the research facilitators and laboratory staff scientists – to advanced CI topics, empowering them to guide others and innovate in the use of CI for materials science.\nTraining is offered in multiple modalities: self-paced modules, video lectures, templates and catalogs, office hours, sessions at the annual CITEAM Users’ Workshop, and tutorials at domain science conferences.\nCITEAM also devotes a significant effort to community building through a three-pronged coordination network comprising imaging laboratories, domain science communities, and experts from national CI resource providers. This approach ensures scalability, sustainability, and broad dissemination of training materials and practices.\nThere are presently two sets of training modules available. The first one is a basic introduction to the Python programming language. Python has quickly become the dominant language for science and engineering, and all our remaining modules will use it. The second module is an introduction to electron microscope image processing and is, of course, written in Python.\nThe remaining modules have, sadly, not been written yet. Take this as an outline of what could be and as a “jumping off point” for further work."
  },
  {
    "objectID": "index.html#introductory-modules",
    "href": "index.html#introductory-modules",
    "title": "About CITEAM",
    "section": "Introductory Modules",
    "text": "Introductory Modules\n\nPRE 100: Python Programming and Jupyter notebooks\nPRE 101: Microscopy Image Processing Basics"
  },
  {
    "objectID": "index.html#software-practices",
    "href": "index.html#software-practices",
    "title": "About CITEAM",
    "section": "Software Practices",
    "text": "Software Practices\n\nSFTW 100: [Cyberinfrastructure and Facilities Available][SFTW100]\nSFTW 101: [Intro to Software Engineering Practices][SFTW101]\nSFTW 201: [Source Code Control and Management][SFTW201]\nSFTW 202: [Making Jupyter Sit Up and Do Tricks][SFTW202]"
  },
  {
    "objectID": "index.html#computational-strategies-for-microscopy",
    "href": "index.html#computational-strategies-for-microscopy",
    "title": "About CITEAM",
    "section": "Computational Strategies for Microscopy",
    "text": "Computational Strategies for Microscopy\n\nCMP 100: [The Electron Microscopy Processing Pipeline: An Introduction][CMP100]\nCMP 101: [I heard you like math…][CMP101]"
  },
  {
    "objectID": "index.html#data-management",
    "href": "index.html#data-management",
    "title": "About CITEAM",
    "section": "Data Management",
    "text": "Data Management\n\nDAT 100: [Introduction to Data Management and FAIR Standards][DAT100]"
  }
]